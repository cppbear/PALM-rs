{
  "name": "regex_syntax::hir::visitor::hir::visitor::HeapVisitor<'a>::visit",
  "name_with_impl": "regex_syntax::hir::visitor::{impl#0}::visit",
  "mod_info": {
    "name": "hir::visitor",
    "loc": "regex-syntax/src/hir/mod.rs:30:1:30:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/visitor.rs:113:5:155:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: visitor.visit_pre(hir)? is Err/None\n"
      ],
      "input_infer": "visitor.visit_pre(hir)? results in Err when visiting Hir instances with an invalid kind or structure, e.g., Kind::Concat with an empty vector, and expected return values cannot be None; thus, values should be in the range where valid HIR and corresponding visitor definitions meet requirements, leading to test input ranges: 1 <= valid_hir_count <= 100, 0 <= visitor_type <= 5, 1 <= hir_depth <= 10.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));",
                "",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    let visitor_output = result.unwrap();",
                  "    assert_eq!(visitor_output, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::concat(vec![Hir::literal(\"a\"), Hir::literal(\"b\")]);  ",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    let visitor_output = result.unwrap();",
                  "    assert_eq!(visitor_output, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:26\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::ne(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:56\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::ne(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                        ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:77\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                            ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                            |\n    |                                                            arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:89\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                                                         ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::ne(HirKind::Literal(\"b\"))]));\n    |                                                                                         ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:110\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                                                             ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                                             |\n    |                                                                                             arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:26\n    |\n272 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::ne(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:56\n    |\n272 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::ne(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                        ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:77\n    |\n272 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                            ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                            |\n    |                                                            arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:89\n    |\n272 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                                                         ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::ne(HirKind::Literal(\"b\"))]));\n    |                                                                                         ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:110\n    |\n272 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                                                             ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                                             |\n    |                                                                                             arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:26\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::ne(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:56\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::ne(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                        ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:77\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                            ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                            |\n    |                                                            arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:89\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                                                         ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::ne(HirKind::Literal(\"b\"))]));\n    |                                                                                         ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:110\n    |\n267 |     let valid_hir = Hir::new(HirKind::Concat(vec![Hir::new(HirKind::Literal(\"a\")), Hir::new(HirKind::Literal(\"b\"))]));\n    |                                                                                             ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                                             |\n    |                                                                                             arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:51\n    |\n272 |     let valid_hir = Hir::concat(vec![Hir::literal(\"a\"), Hir::literal(\"b\")]);  \n    |                                      ------------ ^^^ expected `Literal`, found `&str`\n    |                                      |\n    |                                      arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:70\n    |\n272 |     let valid_hir = Hir::concat(vec![Hir::literal(\"a\"), Hir::literal(\"b\")]);  \n    |                                                         ------------ ^^^ expected `Literal`, found `&str`\n    |                                                         |\n    |                                                         arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let invalid_hir = Hir::new(HirKind::Concat(vec![]));",
                "",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Concat(vec![]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Concat(vec![]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    let output = result.unwrap();",
                  "    assert_eq!(output, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Concat(vec![]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Concat(vec![]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Concat(vec![]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Concat(vec![]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    let output = result.unwrap();",
                  "    assert_eq!(output, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:28\n    |\n267 |     let invalid_hir = Hir::new(HirKind::Concat(vec![]));\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let invalid_hir = Hir::ne(HirKind::Concat(vec![]));\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:28\n    |\n272 |     let invalid_hir = Hir::new(HirKind::Concat(vec![]));\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let invalid_hir = Hir::ne(HirKind::Concat(vec![]));\n    |                            ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:28\n    |\n267 |     let invalid_hir = Hir::new(HirKind::Concat(vec![]));\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let invalid_hir = Hir::ne(HirKind::Concat(vec![]));\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:28\n    |\n272 |     let invalid_hir = Hir::new(HirKind::Concat(vec![]));\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let invalid_hir = Hir::ne(HirKind::Concat(vec![]));\n    |                            ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));",
                "",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), ());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(heap_visitor.stack.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::literal(\"a\");",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::literal(\"a\").repetition();  ",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::literal(\"a\"); ",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), ());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\"))));  ",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::literal(hir::Repetition::new(Hir::literal(\"a\")));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(heap_visitor.stack.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:34\n    |\n267 |     let valid_hir = Hir::literal(\"a\");\n    |                     ------------ ^^^ expected `Literal`, found `&str`\n    |                     |\n    |                     arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:34\n    |\n272 |     let valid_hir = Hir::literal(\"a\").repetition();  \n    |                     ------------ ^^^ expected `Literal`, found `&str`\n    |                     |\n    |                     arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no method named `repetition` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:39\n    |\n272 |     let valid_hir = Hir::literal(\"a\").repetition();  \n    |                     ------------------^^^^^^^^^^--\n    |                     |                 |\n    |                     |                 this is an associated function, not a method\n    |                     help: use associated function syntax instead: `hir::Hir::repetition()`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- method `repetition` not found for this struct\n    |\n    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\nnote: the candidate is defined in an impl for the type `hir::Hir`\n   --> regex-syntax/src/hir/mod.rs:321:5\n    |\n321 |     pub fn repetition(rep: Repetition) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:34\n    |\n267 |     let valid_hir = Hir::literal(\"a\"); \n    |                     ------------ ^^^ expected `Literal`, found `&str`\n    |                     |\n    |                     arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:26\n    |\n272 |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:272:67\n     |\n272  |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n272  |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                                   ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:76\n    |\n272 |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\")))));\n    |                                                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:97\n    |\n272 |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                                ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                                |\n    |                                                                                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:26\n    |\n267 |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\"))));  \n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\"))));  \n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:267:67\n     |\n267  |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\"))));  \n     |                                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n267  |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::literal(\"a\"))));  \n     |                                                                   ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:84\n    |\n267 |     let valid_hir = Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\"))));  \n    |                                                                       ------------ ^^^ expected `Literal`, found `&str`\n    |                                                                       |\n    |                                                                       arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:272:51\n     |\n272  |     let valid_hir = Hir::literal(hir::Repetition::new(Hir::literal(\"a\")));\n     |                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n272  |     let valid_hir = Hir::literal(hir::Repetition::ne(Hir::literal(\"a\")));\n     |                                                   ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:68\n    |\n272 |     let valid_hir = Hir::literal(hir::Repetition::new(Hir::literal(\"a\")));\n    |                                                       ------------ ^^^ expected `Literal`, found `&str`\n    |                                                       |\n    |                                                       arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let invalid_hir = Hir::new(HirKind::Alternation(vec![]));",
                "",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Alternation(vec![]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Alternation(vec![]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Alternation(vec![]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Alternation(vec![]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::new(HirKind::Alternation(vec![]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let invalid_hir = Hir::empty();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&invalid_hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:28\n    |\n267 |     let invalid_hir = Hir::new(HirKind::Alternation(vec![]));\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let invalid_hir = Hir::ne(HirKind::Alternation(vec![]));\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:28\n    |\n272 |     let invalid_hir = Hir::new(HirKind::Alternation(vec![]));\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let invalid_hir = Hir::ne(HirKind::Alternation(vec![]));\n    |                            ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:28\n    |\n267 |     let invalid_hir = Hir::new(HirKind::Alternation(vec![]));\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let invalid_hir = Hir::ne(HirKind::Alternation(vec![]));\n    |                            ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));",
                "",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert_eq!(result.unwrap(), 0);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    let invalid_visitor = MockVisitor::new();",
                  "    invalid_visitor.visit_pre(&valid_hir).err();",
                  "    let invalid_result = heap_visitor.visit(&valid_hir, invalid_visitor);",
                  "    assert!(invalid_result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  ",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  ",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  ",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    assert_eq!(result.unwrap(), 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&valid_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&valid_hir, visitor);",
                  "    let invalid_visitor = MockVisitor::new();",
                  "    invalid_visitor.visit_pre(&valid_hir).err();",
                  "    let invalid_result = heap_visitor.visit(&valid_hir, invalid_visitor);",
                  "    assert!(invalid_result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:267:44\n     |\n267  |     let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  \n     |                                            ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n267  |     let valid_hir = Hir::group(hir::Group::ne(Hir::literal(\"a\")));  \n     |                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:61\n    |\n267 |     let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  \n    |                                                ------------ ^^^ expected `Literal`, found `&str`\n    |                                                |\n    |                                                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:272:44\n     |\n272  |     let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  \n     |                                            ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n272  |     let valid_hir = Hir::group(hir::Group::ne(Hir::literal(\"a\")));  \n     |                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:61\n    |\n272 |     let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  \n    |                                                ------------ ^^^ expected `Literal`, found `&str`\n    |                                                |\n    |                                                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:267:44\n     |\n267  |     let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  \n     |                                            ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n267  |     let valid_hir = Hir::group(hir::Group::ne(Hir::literal(\"a\")));  \n     |                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:61\n    |\n267 |     let valid_hir = Hir::group(hir::Group::new(Hir::literal(\"a\")));  \n    |                                                ------------ ^^^ expected `Literal`, found `&str`\n    |                                                |\n    |                                                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:26\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:272:57\n     |\n272  |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n272  |     let valid_hir = Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:66\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"a\")))));\n    |                                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:87\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                      |\n    |                                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:26\n    |\n267 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:267:57\n     |\n267  |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n267  |     let valid_hir = Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:66\n    |\n267 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"a\")))));\n    |                                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:267:87\n    |\n267 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                      |\n    |                                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:26\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:272:57\n     |\n272  |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n272  |     let valid_hir = Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"a\")))));\n     |                                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:66\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"a\")))));\n    |                                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:87\n    |\n272 |     let valid_hir = Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"a\")))));\n    |                                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                      |\n    |                                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                "        Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                "        Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                "        Hir::new(HirKind::Alternation(vec![",
                "            Hir::new(HirKind::Literal(\"c\")),",
                "            Hir::new(HirKind::Literal(\"d\")),",
                "        ])),",
                "    ]));",
                "",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit(&complex_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::new(HirKind::Literal(\"c\")),",
                  "    Hir::new(HirKind::Literal(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::new(HirKind::Literal(\"c\")),",
                  "    Hir::new(HirKind::Literal(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::new(HirKind::Literal(\"c\")),",
                  "    Hir::new(HirKind::Literal(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::new(HirKind::Literal(\"c\")),",
                  "    Hir::new(HirKind::Literal(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "        Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "        Hir::new(HirKind::Group(hir::Group::new(Hir::literal(\"b\")))),",
                  "        Hir::new(HirKind::Alternation(vec![",
                  "            Hir::new(HirKind::Literal(\"c\")),",
                  "            Hir::literal(Literal::new(\"d\")),  ",
                  "        ])),",
                  "    ]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&complex_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::new(HirKind::Literal(\"c\")),",
                  "    Hir::literal(Literal::new(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "        Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "        Hir::group(hir::Group::new(Hir::literal(\"b\"))),  ",
                  "        Hir::new(HirKind::Alternation(vec![",
                  "            Hir::new(HirKind::Literal(\"c\")),",
                  "            Hir::new(HirKind::Literal(\"d\")),",
                  "        ])),",
                  "    ]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&complex_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  ",
                  "    Hir::group(hir::Group::new(Hir::literal(\"b\"))),  ",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::new(HirKind::Literal(\"c\")),",
                  "    Hir::new(HirKind::Literal(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Default)]",
                  "struct MockVisitor {",
                  "    output: i32,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        Self { output: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = i32;",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "",
                  "    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(self.output)",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "        Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "        Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "        Hir::new(HirKind::Alternation(vec![",
                  "            Hir::new(HirKind::Literal(\"c\")),",
                  "            Hir::new(HirKind::Literal(\"d\")),",
                  "        ])),",
                  "    ]));",
                  "",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit(&complex_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::literal(\"c\"),  ",
                  "    Hir::new(HirKind::Literal(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let complex_hir = Hir::new(HirKind::Concat(vec![",
                  "    Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  ",
                  "    Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),",
                  "    Hir::new(HirKind::Alternation(vec![",
                  "    Hir::new(HirKind::Literal(\"c\")),",
                  "    Hir::new(HirKind::Literal(\"d\")),",
                  "    ])),",
                  "    ]));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&complex_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/visitor.rs:272:26\n    |\n272 |             Hir::literal(Literal::new(\"d\")),  \n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Literal;\n    |\n225 +    use hir::Literal;\n    |\n225 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/visitor.rs:284:18\n    |\n284 |     Hir::literal(Literal::new(\"d\")),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Literal;\n    |\n225 +    use hir::Literal;\n    |\n225 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:28\n    |\n267 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:268:14\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n268 |         Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:268:55\n     |\n268  |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                       ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n268  |         Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                       ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:268:64\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\"))))),\n    |                                                                ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:268:85\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                    ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                    |\n    |                                                                    arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:269:14\n    |\n269 |         Hir::new(HirKind::Group(hir::Group::new(Hir::literal(\"b\")))),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n269 |         Hir::ne(HirKind::Group(hir::Group::new(Hir::literal(\"b\")))),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:269:45\n     |\n269  |         Hir::new(HirKind::Group(hir::Group::new(Hir::literal(\"b\")))),\n     |                                             ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n269  |         Hir::new(HirKind::Group(hir::Group::ne(Hir::literal(\"b\")))),\n     |                                             ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:269:62\n    |\n269 |         Hir::new(HirKind::Group(hir::Group::new(Hir::literal(\"b\")))),\n    |                                                 ------------ ^^^ expected `Literal`, found `&str`\n    |                                                 |\n    |                                                 arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:270:14\n    |\n270 |         Hir::new(HirKind::Alternation(vec![\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n270 |         Hir::ne(HirKind::Alternation(vec![\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:271:18\n    |\n271 |             Hir::new(HirKind::Literal(\"c\")),\n    |                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n271 |             Hir::ne(HirKind::Literal(\"c\")),\n    |                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:271:39\n    |\n271 |             Hir::new(HirKind::Literal(\"c\")),\n    |                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n279 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:280:10\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n280 |     Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:280:51\n     |\n280  |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n280  |     Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:280:60\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\"))))),\n    |                                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:280:81\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                |\n    |                                                                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:281:10\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n281 |     Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:281:41\n     |\n281  |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n281  |     Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:281:50\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"b\"))))),\n    |                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:281:71\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                      |\n    |                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:282:10\n    |\n282 |     Hir::new(HirKind::Alternation(vec![\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n282 |     Hir::ne(HirKind::Alternation(vec![\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:283:10\n    |\n283 |     Hir::new(HirKind::Literal(\"c\")),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n283 |     Hir::ne(HirKind::Literal(\"c\")),\n    |          ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:283:31\n    |\n283 |     Hir::new(HirKind::Literal(\"c\")),\n    |              ---------------- ^^^ expected `Literal`, found `&str`\n    |              |\n    |              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:28\n    |\n267 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:268:14\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n268 |         Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:268:55\n     |\n268  |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                       ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n268  |         Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                       ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:268:64\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\"))))),\n    |                                                                ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:268:85\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                    ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                    |\n    |                                                                    arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:269:32\n     |\n269  |         Hir::group(hir::Group::new(Hir::literal(\"b\"))),  \n     |                                ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n269  |         Hir::group(hir::Group::ne(Hir::literal(\"b\"))),  \n     |                                ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:269:49\n    |\n269 |         Hir::group(hir::Group::new(Hir::literal(\"b\"))),  \n    |                                    ------------ ^^^ expected `Literal`, found `&str`\n    |                                    |\n    |                                    arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:270:14\n    |\n270 |         Hir::new(HirKind::Alternation(vec![\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n270 |         Hir::ne(HirKind::Alternation(vec![\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:271:18\n    |\n271 |             Hir::new(HirKind::Literal(\"c\")),\n    |                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n271 |             Hir::ne(HirKind::Literal(\"c\")),\n    |                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:271:39\n    |\n271 |             Hir::new(HirKind::Literal(\"c\")),\n    |                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:18\n    |\n272 |             Hir::new(HirKind::Literal(\"d\")),\n    |                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |             Hir::ne(HirKind::Literal(\"d\")),\n    |                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:39\n    |\n272 |             Hir::new(HirKind::Literal(\"d\")),\n    |                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n279 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:280:10\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n280 |     Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:280:51\n     |\n280  |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n     |                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n280  |     Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::literal(\"a\")))),  \n     |                                                   ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:280:68\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n    |                                                       ------------ ^^^ expected `Literal`, found `&str`\n    |                                                       |\n    |                                                       arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:281:28\n     |\n281  |     Hir::group(hir::Group::new(Hir::literal(\"b\"))),  \n     |                            ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n281  |     Hir::group(hir::Group::ne(Hir::literal(\"b\"))),  \n     |                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:281:45\n    |\n281 |     Hir::group(hir::Group::new(Hir::literal(\"b\"))),  \n    |                                ------------ ^^^ expected `Literal`, found `&str`\n    |                                |\n    |                                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:282:10\n    |\n282 |     Hir::new(HirKind::Alternation(vec![\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n282 |     Hir::ne(HirKind::Alternation(vec![\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:283:10\n    |\n283 |     Hir::new(HirKind::Literal(\"c\")),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n283 |     Hir::ne(HirKind::Literal(\"c\")),\n    |          ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:283:31\n    |\n283 |     Hir::new(HirKind::Literal(\"c\")),\n    |              ---------------- ^^^ expected `Literal`, found `&str`\n    |              |\n    |              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:284:10\n    |\n284 |     Hir::new(HirKind::Literal(\"d\")),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n284 |     Hir::ne(HirKind::Literal(\"d\")),\n    |          ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:284:31\n    |\n284 |     Hir::new(HirKind::Literal(\"d\")),\n    |              ---------------- ^^^ expected `Literal`, found `&str`\n    |              |\n    |              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:289:28\n    |\n289 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n289 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:290:10\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n290 |     Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:290:51\n     |\n290  |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n290  |     Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:290:60\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\"))))),\n    |                                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:290:81\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                |\n    |                                                                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:291:10\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n291 |     Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:291:41\n     |\n291  |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n291  |     Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:291:50\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"b\"))))),\n    |                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:291:71\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                      |\n    |                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:267:28\n    |\n267 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n267 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:268:14\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n268 |         Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:268:55\n     |\n268  |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                       ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n268  |         Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                       ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:268:64\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\"))))),\n    |                                                                ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:268:85\n    |\n268 |         Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                    ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                    |\n    |                                                                    arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:269:14\n    |\n269 |         Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n269 |         Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:269:45\n     |\n269  |         Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                             ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n269  |         Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                             ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:269:54\n    |\n269 |         Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                      ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n269 |         Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"b\"))))),\n    |                                                      ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:269:75\n    |\n269 |         Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                          ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                          |\n    |                                                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:270:14\n    |\n270 |         Hir::new(HirKind::Alternation(vec![\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n270 |         Hir::ne(HirKind::Alternation(vec![\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:271:18\n    |\n271 |             Hir::new(HirKind::Literal(\"c\")),\n    |                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n271 |             Hir::ne(HirKind::Literal(\"c\")),\n    |                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:271:39\n    |\n271 |             Hir::new(HirKind::Literal(\"c\")),\n    |                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:272:18\n    |\n272 |             Hir::new(HirKind::Literal(\"d\")),\n    |                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n272 |             Hir::ne(HirKind::Literal(\"d\")),\n    |                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:272:39\n    |\n272 |             Hir::new(HirKind::Literal(\"d\")),\n    |                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n279 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:280:10\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n280 |     Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:280:51\n     |\n280  |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n280  |     Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:280:60\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\"))))),\n    |                                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:280:81\n    |\n280 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                |\n    |                                                                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:281:10\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n281 |     Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:281:41\n     |\n281  |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n281  |     Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:281:50\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"b\"))))),\n    |                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:281:71\n    |\n281 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                      |\n    |                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:282:10\n    |\n282 |     Hir::new(HirKind::Alternation(vec![\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n282 |     Hir::ne(HirKind::Alternation(vec![\n    |          ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:283:18\n    |\n283 |     Hir::literal(\"c\"),  \n    |     ------------ ^^^ expected `Literal`, found `&str`\n    |     |\n    |     arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:284:10\n    |\n284 |     Hir::new(HirKind::Literal(\"d\")),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n284 |     Hir::ne(HirKind::Literal(\"d\")),\n    |          ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:284:31\n    |\n284 |     Hir::new(HirKind::Literal(\"d\")),\n    |              ---------------- ^^^ expected `Literal`, found `&str`\n    |              |\n    |              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:289:28\n    |\n289 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n289 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:290:10\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n290 |     Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:290:51\n     |\n290  |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n290  |     Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::new(HirKind::Literal(\"a\"))))),\n     |                                                   ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:290:60\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::ne(HirKind::Literal(\"a\"))))),\n    |                                                            ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:290:81\n    |\n290 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::new(HirKind::Literal(\"a\"))))),\n    |                                                                ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                                |\n    |                                                                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:291:10\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n291 |     Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:291:41\n     |\n291  |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n291  |     Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:291:50\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"b\"))))),\n    |                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:291:71\n    |\n291 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                      |\n    |                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:296:28\n    |\n296 |     let complex_hir = Hir::new(HirKind::Concat(vec![\n    |                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n296 |     let complex_hir = Hir::ne(HirKind::Concat(vec![\n    |                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:297:10\n    |\n297 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n297 |     Hir::ne(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Repetition` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:297:51\n     |\n297  |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n     |                                                   ^^^ function or associated item not found in `Repetition`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1187:1\n     |\n1187 | pub struct Repetition {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n297  |     Hir::new(HirKind::Repetition(hir::Repetition::ne(Hir::literal(\"a\")))),  \n     |                                                   ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:297:68\n    |\n297 |     Hir::new(HirKind::Repetition(hir::Repetition::new(Hir::literal(\"a\")))),  \n    |                                                       ------------ ^^^ expected `Literal`, found `&str`\n    |                                                       |\n    |                                                       arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:298:10\n    |\n298 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n298 |     Hir::ne(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Group` in the current scope\n    --> regex-syntax/src/hir/visitor.rs:298:41\n     |\n298  |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ^^^ function or associated item not found in `hir::Group`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1155:1\n     |\n1155 | pub struct Group {\n     | ---------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n298  |     Hir::new(HirKind::Group(hir::Group::ne(Hir::new(HirKind::Literal(\"b\"))))),\n     |                                         ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:298:50\n    |\n298 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                  ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n298 |     Hir::new(HirKind::Group(hir::Group::new(Hir::ne(HirKind::Literal(\"b\"))))),\n    |                                                  ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:298:71\n    |\n298 |     Hir::new(HirKind::Group(hir::Group::new(Hir::new(HirKind::Literal(\"b\"))))),\n    |                                                      ---------------- ^^^ expected `Literal`, found `&str`\n    |                                                      |\n    |                                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:299:10\n    |\n299 |     Hir::new(HirKind::Alternation(vec![\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n299 |     Hir::ne(HirKind::Alternation(vec![\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:300:10\n    |\n300 |     Hir::new(HirKind::Literal(\"c\")),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n300 |     Hir::ne(HirKind::Literal(\"c\")),\n    |          ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:300:31\n    |\n300 |     Hir::new(HirKind::Literal(\"c\")),\n    |              ---------------- ^^^ expected `Literal`, found `&str`\n    |              |\n    |              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:301:10\n    |\n301 |     Hir::new(HirKind::Literal(\"d\")),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n301 |     Hir::ne(HirKind::Literal(\"d\")),\n    |          ~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/visitor.rs:301:31\n    |\n301 |     Hir::new(HirKind::Literal(\"d\")),\n    |              ---------------- ^^^ expected `Literal`, found `&str`\n    |              |\n    |              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/hir/mod.rs:175:5\n    |\n175 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 49 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: visitor.visit_pre(hir)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct(hir) is true\n",
        "// constraint: visitor.visit_post(hir)? is Err/None\n"
      ],
      "input_infer": "1 <= hir.kind <= 10, 1 <= stack.size <= 5, 1 <= visitor output <= 5, 1 <= visitor error <= 3\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let repetition = hir::Repetition { /* fields initialization */ };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);"
                ],
                [
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);"
                ],
                [
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.stack.len(), 1);"
                ],
                [
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);",
                  "}"
                ],
                [
                  "{",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);",
                  "}"
                ],
                [
                  "{",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let repetition = hir::Repetition { /* fields initialization */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:74\n    |\n234 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:74\n    |\n239 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:233:22\n    |\n233 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:238:22\n    |\n238 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:240:23\n    |\n240 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:74\n    |\n234 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:74\n    |\n239 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:233:22\n    |\n233 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:238:22\n    |\n238 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:240:23\n    |\n240 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:74\n    |\n234 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:74\n    |\n239 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:233:22\n    |\n233 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:238:22\n    |\n238 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:240:23\n    |\n240 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:74\n    |\n234 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:74\n    |\n239 |     let hir = Hir { kind: HirKind::Repetition(repetition.clone()), info: HirInfo::default() };\n    |                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:233:22\n    |\n233 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:238:22\n    |\n238 |     let repetition = hir::Repetition { /* fields initialization */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:240:23\n    |\n240 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let group = hir::Group { /* fields initialization */ };",
                "    let hir = Hir { kind: HirKind::Group(group.clone()), info: HirInfo::default() };",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(visitor.start_called, true);"
                ],
                [
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(visitor.visit_pre_called, true);"
                ],
                [
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(visitor.visit_post_called, true);"
                ],
                [
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(heap_visitor.stack.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(visitor.start_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(visitor.visit_pre_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(visitor.visit_post_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };",
                  "    let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };",
                  "    let concat = hir::Concat { children: vec![head, tail], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(heap_visitor.stack.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n235 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n235 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:58\n    |\n236 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:23\n    |\n242 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n242 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n242 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:243:58\n    |\n243 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n235 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n235 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:58\n    |\n236 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:240:64\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:23\n    |\n242 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n242 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n242 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:243:58\n    |\n243 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:240:49\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n235 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n235 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:58\n    |\n236 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:240:64\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:23\n    |\n242 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n242 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n242 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:243:58\n    |\n243 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:240:49\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n235 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n235 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:58\n    |\n236 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:240:64\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:23\n    |\n242 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n242 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n242 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:243:58\n    |\n243 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:240:49\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n235 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n235 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:58\n    |\n236 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:240:64\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:23\n    |\n242 |     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n242 -     let concat = hir::Concat { children: vec![head, tail], /* other fields */ };\n242 +     let concat = Concat { children: vec![head, tail], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:243:58\n    |\n243 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:240:49\n    |\n240 |     let head = Hir { kind: HirKind::Literal(\"a\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let tail = Hir { kind: HirKind::Literal(\"b\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(result.unwrap(), expected_output);"
                ],
                [
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.some_state_check());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert_eq!(result.unwrap(), expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };",
                  "    let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };",
                  "    let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };",
                  "",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.some_state_check());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n235 +     let alternation = Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:240:64\n    |\n240 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:28\n    |\n242 |     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n242 -     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n242 +     let alternation = Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:243:68\n    |\n243 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:240:49\n    |\n240 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n235 +     let alternation = Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:240:64\n    |\n240 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:28\n    |\n242 |     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n242 -     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n242 +     let alternation = Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:243:68\n    |\n243 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0425]: cannot find value `expected_output` in this scope\n   --> regex-syntax/src/hir/visitor.rs:247:33\n    |\n247 |     assert_eq!(result.unwrap(), expected_output);\n    |                                 ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:240:49\n    |\n240 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:64\n    |\n233 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:64\n    |\n234 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n235 +     let alternation = Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:240:64\n    |\n240 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:64\n    |\n241 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                                ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:242:28\n    |\n242 |     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n242 -     let alternation = hir::Alternation { branches: vec![alt1, alt2], /* other fields */ };\n242 +     let alternation = Alternation { branches: vec![alt1, alt2], /* other fields */ };\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:234:49\n    |\n234 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:240:49\n    |\n240 |     let alt1 = Hir { kind: HirKind::Literal(\"x\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<&str>` is not satisfied\n   --> regex-syntax/src/hir/visitor.rs:241:49\n    |\n241 |     let alt2 = Hir { kind: HirKind::Literal(\"y\".into()), info: HirInfo::default() };\n    |                                                 ^^^^ the trait `From<&str>` is not implemented for `hir::Literal`, which is required by `&str: Into<_>`\n    |\n    = note: required for `&str` to implement `Into<hir::Literal>`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:244:23\n    |\n244 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let concat = hir::Concat { children: Vec::new() };",
                "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.visit(&hir, visitor), Err(expected_error));"
                ],
                [
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);"
                ],
                [
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);"
                ],
                [
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.visit(&hir, visitor), Err(expected_error));",
                  "}"
                ],
                [
                  "{",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);",
                  "}"
                ],
                [
                  "{",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);",
                  "}"
                ],
                [
                  "{",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let concat = hir::Concat { children: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:233:23\n    |\n233 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n233 -     let concat = hir::Concat { children: Vec::new() };\n233 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:58\n    |\n234 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n238 -     let concat = hir::Concat { children: Vec::new() };\n238 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:58\n    |\n239 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0425]: cannot find value `expected_error` in this scope\n   --> regex-syntax/src/hir/visitor.rs:242:55\n    |\n242 |     assert_eq!(heap_visitor.visit(&hir, visitor), Err(expected_error));\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:240:23\n    |\n240 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:233:23\n    |\n233 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n233 -     let concat = hir::Concat { children: Vec::new() };\n233 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:234:58\n    |\n234 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n238 -     let concat = hir::Concat { children: Vec::new() };\n238 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:58\n    |\n239 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:240:23\n    |\n240 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n230 -     let concat = hir::Concat { children: Vec::new() };\n230 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:231:58\n    |\n231 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n235 -     let concat = hir::Concat { children: Vec::new() };\n235 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:58\n    |\n236 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:232:23\n    |\n232 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n230 -     let concat = hir::Concat { children: Vec::new() };\n230 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:231:58\n    |\n231 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |     let concat = hir::Concat { children: Vec::new() };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n235 -     let concat = hir::Concat { children: Vec::new() };\n235 +     let concat = Concat { children: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:58\n    |\n236 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo::default() };\n    |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:232:23\n    |\n232 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alternation = hir::Alternation { branches: Vec::new() };",
                "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit(&hir, visitor).is_ok());"
                ],
                [
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.visit_pre_called, true);"
                ],
                [
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.visit_post_called, false);"
                ],
                [
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.alternation_in_called, true);"
                ],
                [
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.stack.is_empty(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit(&hir, visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.visit_pre_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.visit_post_called, false);",
                  "}"
                ],
                [
                  "{",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.alternation_in_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let alternation = hir::Alternation { branches: Vec::new() };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.stack.is_empty(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:230:28\n    |\n230 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n230 -     let alternation = hir::Alternation { branches: Vec::new() };\n230 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:231:68\n    |\n231 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: Vec::new() };\n235 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:232:23\n    |\n232 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:230:28\n    |\n230 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n230 -     let alternation = hir::Alternation { branches: Vec::new() };\n230 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:231:68\n    |\n231 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: Vec::new() };\n235 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:232:23\n    |\n232 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:230:28\n    |\n230 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n230 -     let alternation = hir::Alternation { branches: Vec::new() };\n230 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:231:68\n    |\n231 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: Vec::new() };\n235 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:232:23\n    |\n232 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:230:28\n    |\n230 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n230 -     let alternation = hir::Alternation { branches: Vec::new() };\n230 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:231:68\n    |\n231 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: Vec::new() };\n235 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:232:23\n    |\n232 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:230:28\n    |\n230 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n230 -     let alternation = hir::Alternation { branches: Vec::new() };\n230 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:231:68\n    |\n231 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:235:28\n    |\n235 |     let alternation = hir::Alternation { branches: Vec::new() };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n235 -     let alternation = hir::Alternation { branches: Vec::new() };\n235 +     let alternation = Alternation { branches: Vec::new() };\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/visitor.rs:236:68\n    |\n236 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() };\n    |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:232:23\n    |\n232 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: visitor.visit_pre(hir)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct(hir) is true\n",
        "// constraint: visitor.visit_post(hir)? is Ok/Some\n",
        "// constraint: self.stack.pop() matches Some((post_hir, frame)) is true\n",
        "// constraint: let Some(x) = self.pop(frame) is true\n",
        "// constraint: visitor.visit_post(post_hir)? is Err/None\n"
      ],
      "input_infer": "1 <= hir.kind <= 100, 1 <= stack.len() <= 50, 1 <= tail.len() <= 20, 1 <= head.len() <= 20\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = MockVisitor::new();",
                "    let repetition_hir = Hir { /* appropriate initialization */ };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&repetition_hir, visitor);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = MockVisitor::new();",
                "    let group_hir = Hir { /* appropriate initialization */ };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&group_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    assert_eq!(visitor.calls, vec![\"start\", \"visit_pre\", \"visit_post\"]);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    visitor.error = Some(\"error occurred\");",
                  "    let result_with_error = heap_visitor.visit(&group_hir, visitor);",
                  "    assert!(result_with_error.is_err());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    visitor.error = Some(\"error occurred\");",
                  "    let result_with_error = heap_visitor.visit(&group_hir, visitor);",
                  "    assert_eq!(visitor.calls, vec![\"start\", \"visit_pre\", \"visit_post\"]);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    visitor.error = Some(\"error occurred\");",
                  "    let result_with_error = heap_visitor.visit(&group_hir, visitor);",
                  "    assert_eq!(visitor.error, Some(\"error occurred\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    assert_eq!(visitor.calls, vec![\"start\", \"visit_pre\", \"visit_post\"]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    visitor.error = Some(\"error occurred\");",
                  "    let result_with_error = heap_visitor.visit(&group_hir, visitor);",
                  "    assert!(result_with_error.is_err());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    visitor.error = Some(\"error occurred\");",
                  "    let result_with_error = heap_visitor.visit(&group_hir, visitor);",
                  "    assert_eq!(visitor.calls, vec![\"start\", \"visit_pre\", \"visit_post\"]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&group_hir, visitor);",
                  "    visitor.error = Some(\"error occurred\");",
                  "    let result_with_error = heap_visitor.visit(&group_hir, visitor);",
                  "    assert_eq!(visitor.error, Some(\"error occurred\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:21\n    |\n278 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:21\n    |\n282 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:21\n    |\n278 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:21\n    |\n282 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:21\n    |\n278 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:21\n    |\n282 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:21\n    |\n278 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:21\n    |\n282 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:21\n    |\n278 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:21\n    |\n282 |     let group_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = MockVisitor::new();",
                "    let concat_hir = Hir { /* appropriate initialization */ };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&concat_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"start\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_pre\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_post\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_alternation_in\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert_eq!(visitor.error, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"start\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_pre\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_post\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_alternation_in\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&concat_hir, visitor);",
                  "    assert_eq!(visitor.error, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:22\n    |\n278 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:22\n    |\n282 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:22\n    |\n278 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:22\n    |\n282 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:22\n    |\n278 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:22\n    |\n282 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:22\n    |\n278 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:22\n    |\n282 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:22\n    |\n278 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:22\n    |\n282 |     let concat_hir = Hir { /* appropriate initialization */ };\n    |                      ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = MockVisitor::new();",
                "    let alternation_hir = Hir { /* appropriate initialization */ };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&alternation_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert_eq!(visitor_calls, vec![\"start\", \"visit_pre\"]);"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert!(visitor.error.is_none());"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert!(heap_visitor.stack.is_empty());"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert!(visitor_calls.len() > 2);"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert_eq!(visitor_calls.last(), Some(&\"visit_post\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&alternation_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert_eq!(visitor_calls, vec![\"start\", \"visit_pre\"]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&alternation_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert!(visitor.error.is_none());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&alternation_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert!(heap_visitor.stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&alternation_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert!(visitor_calls.len() > 2);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&alternation_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let visitor_calls = visitor.calls.clone();",
                  "    assert_eq!(visitor_calls.last(), Some(&\"visit_post\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:27\n    |\n278 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:27\n    |\n282 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:27\n    |\n278 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:27\n    |\n282 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:27\n    |\n278 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:27\n    |\n282 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:27\n    |\n278 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:27\n    |\n282 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:278:27\n    |\n278 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:282:27\n    |\n282 |     let alternation_hir = Hir { /* appropriate initialization */ };\n    |                           ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let visitor = MockVisitor::new();",
                "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&empty_concat_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"start\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_pre\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_post\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_alternation_in\"));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.len() > 0);"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.error.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"start\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_pre\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_post\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.contains(&\"visit_alternation_in\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.calls.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_concat_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_concat_hir, visitor);",
                  "    assert!(visitor.error.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:283:28\n    |\n283 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:283:28\n    |\n283 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:283:28\n    |\n283 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:283:28\n    |\n283 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:283:28\n    |\n283 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:28\n    |\n279 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:283:28\n    |\n283 |     let empty_concat_hir = Hir { /* appropriate initialization */ };\n    |                            ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let visitor = MockVisitor::new();",
                "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.calls, vec![\"start\", \"visit_pre\"]);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.error.is_none());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.stack.is_empty());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.calls.last(), Some(&\"visit_post\"));"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.finish().is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.stack.len() >= 1);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.calls.contains(&\"visit_alternation_in\"));"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.pop(frame), None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.calls, vec![\"start\", \"visit_pre\"]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.error.is_none());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.calls.last(), Some(&\"visit_post\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.finish().is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.stack.len() >= 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.calls.contains(&\"visit_alternation_in\"));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = MockVisitor::new();",
                  "    let empty_alternation_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&empty_alternation_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.pop(frame), None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:284:13\n    |\n276 | fn test_visit_59()\n    |    ------------- this function can't have a `self` parameter\n...\n284 |     assert!(self.stack.is_empty());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0424, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:284:13\n    |\n276 | fn test_visit_62()\n    |    ------------- this function can't have a `self` parameter\n...\n284 |     assert!(self.stack.len() >= 1);\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0424, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:284:16\n    |\n276 | fn test_visit_64()\n    |    ------------- this function can't have a `self` parameter\n...\n284 |     assert_eq!(self.pop(frame), None);\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0425]: cannot find value `frame` in this scope\n   --> regex-syntax/src/hir/visitor.rs:284:25\n    |\n284 |     assert_eq!(self.pop(frame), None);\n    |                         ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:33\n    |\n279 |     let empty_alternation_hir = Hir { /* appropriate initialization */ };\n    |                                 ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0424, E0425, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    visitor.error = Some(\"error\");",
                "    let error_hir = Hir { /* appropriate initialization */ };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.visit(&error_hir, visitor);",
                "    assert_eq!(result, Err(\"error\"));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    visitor.error = Some(\"error\");",
                  "    let error_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&error_hir, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    visitor.error = Some(\"error\");",
                  "    let error_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&error_hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), \"error\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    visitor.error = Some(\"error\");",
                  "    let error_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&error_hir, visitor);",
                  "    assert_eq!(result, Err(\"error\"));",
                  "    let mut visitor = MockVisitor::new();",
                  "    visitor.error = Some(\"error\");",
                  "    let error_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&error_hir, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Debug)]",
                  "struct MockVisitor {",
                  "    calls: Vec<&'static str>,",
                  "    error: Option<&'static str>,",
                  "}",
                  "",
                  "impl MockVisitor {",
                  "    fn new() -> Self {",
                  "        MockVisitor {",
                  "            calls: Vec::new(),",
                  "            error: None,",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "impl Visitor for MockVisitor {",
                  "    type Output = ();",
                  "    type Err = &'static str;",
                  "",
                  "    fn start(&mut self) {",
                  "        self.calls.push(\"start\");",
                  "    }",
                  "",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_pre\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_post\");",
                  "        if self.error.is_some() {",
                  "            Err(self.error.unwrap())",
                  "        } else {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.calls.push(\"visit_alternation_in\");",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let mut visitor = MockVisitor::new();",
                  "    visitor.error = Some(\"error\");",
                  "    let error_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&error_hir, visitor);",
                  "    assert_eq!(result, Err(\"error\"));",
                  "    let mut visitor = MockVisitor::new();",
                  "    visitor.error = Some(\"error\");",
                  "    let error_hir = Hir { /* appropriate initialization */ };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&error_hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), \"error\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:21\n    |\n279 |     let error_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:285:21\n    |\n285 |     let error_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:279:21\n    |\n279 |     let error_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:285:21\n    |\n285 |     let error_hir = Hir { /* appropriate initialization */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: visitor.visit_pre(hir)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct(hir) is true\n",
        "// constraint: visitor.visit_post(hir)? is Ok/Some\n",
        "// constraint: self.stack.pop() matches Some((post_hir, frame)) is true\n",
        "// constraint: let Some(x) = self.pop(frame) is true\n",
        "// constraint: visitor.visit_post(post_hir)? is Ok/Some\n",
        "// constraint: self.stack.pop() matches None is true\n",
        "// constraint: self.stack.pop() matches None is true\n"
      ],
      "input_infer": "1 <= hir kind <= 10, 1 <= stack length <= 5, 1 <= concat length <= 3, 1 <= alternation length <= 3\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(MockRepetition::new()),",
                "        info: MockHirInfo::new(),",
                "    };",
                "    let mut visitor_impl = HeapVisitor::new();",
                "    let _ = visitor_impl.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let group_hir = Hir {",
                "        kind: HirKind::Group(MockGroup::new()),",
                "        info: MockHirInfo::new(),",
                "    };",
                "    let mut visitor_impl = HeapVisitor::new();",
                "    let _ = visitor_impl.visit(&group_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert_eq!(visitor.start_called, true);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert!(visitor.finish_called);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir {",
                  "        kind: HirKind::Group(MockGroup::new()),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert_eq!(visitor.start_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir {",
                  "        kind: HirKind::Group(MockGroup::new()),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir {",
                  "        kind: HirKind::Group(MockGroup::new()),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir {",
                  "        kind: HirKind::Group(MockGroup::new()),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&group_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    assert!(visitor.finish_called);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:232:30\n    |\n232 |         kind: HirKind::Group(MockGroup::new()),\n    |                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:15\n    |\n233 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:48\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:238:73\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                                         ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:232:30\n    |\n232 |         kind: HirKind::Group(MockGroup::new()),\n    |                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:15\n    |\n233 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:48\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:238:73\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                                         ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:232:30\n    |\n232 |         kind: HirKind::Group(MockGroup::new()),\n    |                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:15\n    |\n233 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:48\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:238:73\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                                         ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:232:30\n    |\n232 |         kind: HirKind::Group(MockGroup::new()),\n    |                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:233:15\n    |\n233 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:237:23\n    |\n237 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:48\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:238:73\n    |\n238 |     let group_hir = Hir { kind: HirKind::Group(MockGroup::new()), info: MockHirInfo::new(), };\n    |                                                                         ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let concat_hir = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Hir {",
                "                kind: HirKind::Group(MockGroup::new()),",
                "                info: MockHirInfo::new(),",
                "            },",
                "            Hir {",
                "                kind: HirKind::Repetition(MockRepetition::new()),",
                "                info: MockHirInfo::new(),",
                "            },",
                "        ]),",
                "        info: MockHirInfo::new(),",
                "    };",
                "    let mut visitor_impl = HeapVisitor::new();",
                "    let _ = visitor_impl.visit(&concat_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.start_called());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.visit_pre_called());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.visit_post_called());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.visit_alternation_in_called());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&concat_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&concat_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.start_called());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&concat_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.visit_pre_called());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&concat_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.visit_post_called());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&concat_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let concat_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&concat_hir, visitor);",
                  "    assert!(visitor.visit_alternation_in_called());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:238:43\n    |\n238 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:246:23\n    |\n246 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:250:26\n    |\n250 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:11\n    |\n251 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:254:31\n    |\n254 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:255:11\n    |\n255 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:258:11\n    |\n258 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:238:43\n    |\n238 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:246:23\n    |\n246 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:250:26\n    |\n250 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:11\n    |\n251 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:254:31\n    |\n254 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:255:11\n    |\n255 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:258:11\n    |\n258 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:238:43\n    |\n238 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:246:23\n    |\n246 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:250:26\n    |\n250 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:11\n    |\n251 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:254:31\n    |\n254 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:255:11\n    |\n255 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:258:11\n    |\n258 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:238:43\n    |\n238 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:246:23\n    |\n246 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:250:26\n    |\n250 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:11\n    |\n251 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:254:31\n    |\n254 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:255:11\n    |\n255 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:258:11\n    |\n258 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:238:43\n    |\n238 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:246:23\n    |\n246 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:250:26\n    |\n250 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:11\n    |\n251 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:254:31\n    |\n254 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:255:11\n    |\n255 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:258:11\n    |\n258 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let alternation_hir = Hir {",
                "        kind: HirKind::Alternation(vec![",
                "            Hir {",
                "                kind: HirKind::Repetition(MockRepetition::new()),",
                "                info: MockHirInfo::new(),",
                "            },",
                "            Hir {",
                "                kind: HirKind::Group(MockGroup::new()),",
                "                info: MockHirInfo::new(),",
                "            },",
                "        ]),",
                "        info: MockHirInfo::new(),",
                "    };",
                "    let mut visitor_impl = HeapVisitor::new();",
                "    let _ = visitor_impl.visit(&alternation_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    assert!(self.stack.len() > 0);"
                ],
                [
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    assert!(matches!(self.induct(&alternation_hir), Some(Frame::Alternation { .. })));"
                ],
                [
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    visitor.visit_post(&alternation_hir).unwrap();",
                  "    let (post_hir, frame) = self.stack.pop().unwrap();",
                  "    assert!(matches!(frame, Frame::Alternation { .. }));"
                ],
                [
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    visitor.visit_post(&alternation_hir).unwrap();",
                  "    let (post_hir, frame) = self.stack.pop().unwrap();",
                  "    assert!(self.stack.is_empty());"
                ],
                [
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    visitor.visit_post(&alternation_hir).unwrap();",
                  "    let (post_hir, frame) = self.stack.pop().unwrap();",
                  "    assert!(self.stack.pop().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir {",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&alternation_hir, visitor);",
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    assert!(self.stack.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir {",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&alternation_hir, visitor);",
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    assert!(matches!(self.induct(&alternation_hir), Some(Frame::Alternation { .. })));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir {",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&alternation_hir, visitor);",
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    visitor.visit_post(&alternation_hir).unwrap();",
                  "    let (post_hir, frame) = self.stack.pop().unwrap();",
                  "    assert!(matches!(frame, Frame::Alternation { .. }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir {",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&alternation_hir, visitor);",
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    visitor.visit_post(&alternation_hir).unwrap();",
                  "    let (post_hir, frame) = self.stack.pop().unwrap();",
                  "    assert!(self.stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let alternation_hir = Hir {",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir {",
                  "                kind: HirKind::Repetition(MockRepetition::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&alternation_hir, visitor);",
                  "    visitor.start();",
                  "    visitor.visit_pre(&alternation_hir).unwrap();",
                  "    visitor.visit_post(&alternation_hir).unwrap();",
                  "    let (post_hir, frame) = self.stack.pop().unwrap();",
                  "    assert!(self.stack.pop().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:248:13\n    |\n228 | fn test_visit_76()\n    |    ------------- this function can't have a `self` parameter\n...\n248 |     assert!(self.stack.len() > 0);\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:234:43\n    |\n234 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:38\n    |\n238 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0424`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:248:22\n    |\n228 | fn test_visit_77()\n    |    ------------- this function can't have a `self` parameter\n...\n248 |     assert!(matches!(self.induct(&alternation_hir), Some(Frame::Alternation { .. })));\n    |                      ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:234:43\n    |\n234 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:38\n    |\n238 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0424`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:249:29\n    |\n228 | fn test_visit_78()\n    |    ------------- this function can't have a `self` parameter\n...\n249 |     let (post_hir, frame) = self.stack.pop().unwrap();\n    |                             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:234:43\n    |\n234 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:38\n    |\n238 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0424`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:249:29\n    |\n228 | fn test_visit_79()\n    |    ------------- this function can't have a `self` parameter\n...\n249 |     let (post_hir, frame) = self.stack.pop().unwrap();\n    |                             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:250:13\n    |\n228 | fn test_visit_79()\n    |    ------------- this function can't have a `self` parameter\n...\n250 |     assert!(self.stack.is_empty());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:234:43\n    |\n234 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:38\n    |\n238 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0424`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:249:29\n    |\n228 | fn test_visit_80()\n    |    ------------- this function can't have a `self` parameter\n...\n249 |     let (post_hir, frame) = self.stack.pop().unwrap();\n    |                             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:250:13\n    |\n228 | fn test_visit_80()\n    |    ------------- this function can't have a `self` parameter\n...\n250 |     assert!(self.stack.pop().is_none());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:234:43\n    |\n234 |                 kind: HirKind::Repetition(MockRepetition::new()),\n    |                                           ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:238:38\n    |\n238 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:239:23\n    |\n239 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:242:15\n    |\n242 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0424`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let nested_hir = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Hir {",
                "                kind: HirKind::Group(MockGroup::new()),",
                "                info: MockHirInfo::new(),",
                "            },",
                "            Hir {",
                "                kind: HirKind::Alternation(vec![",
                "                    Hir {",
                "                        kind: HirKind::Repetition(MockRepetition::new()),",
                "                        info: MockHirInfo::new(),",
                "                    },",
                "                    Hir {",
                "                        kind: HirKind::Group(MockGroup::new()),",
                "                        info: MockHirInfo::new(),",
                "                    },",
                "                ]),",
                "                info: MockHirInfo::new(),",
                "            },",
                "        ]),",
                "        info: MockHirInfo::new(),",
                "    };",
                "    let mut visitor_impl = HeapVisitor::new();",
                "    let _ = visitor_impl.visit(&nested_hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.start_called, true);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.visit_pre_called, true);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.visit_post_called, true);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.visit_alternation_in_called, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Alternation(vec![",
                  "                    Hir {",
                  "                        kind: HirKind::Repetition(MockRepetition::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                    Hir {",
                  "                        kind: HirKind::Group(MockGroup::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                ]),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&nested_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Alternation(vec![",
                  "                    Hir {",
                  "                        kind: HirKind::Repetition(MockRepetition::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                    Hir {",
                  "                        kind: HirKind::Group(MockGroup::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                ]),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&nested_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.start_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Alternation(vec![",
                  "                    Hir {",
                  "                        kind: HirKind::Repetition(MockRepetition::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                    Hir {",
                  "                        kind: HirKind::Group(MockGroup::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                ]),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&nested_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.visit_pre_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Alternation(vec![",
                  "                    Hir {",
                  "                        kind: HirKind::Repetition(MockRepetition::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                    Hir {",
                  "                        kind: HirKind::Group(MockGroup::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                ]),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&nested_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.visit_post_called, true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Group(MockGroup::new()),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "            Hir {",
                  "                kind: HirKind::Alternation(vec![",
                  "                    Hir {",
                  "                        kind: HirKind::Repetition(MockRepetition::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                    Hir {",
                  "                        kind: HirKind::Group(MockGroup::new()),",
                  "                        info: MockHirInfo::new(),",
                  "                    },",
                  "                ]),",
                  "                info: MockHirInfo::new(),",
                  "            },",
                  "        ]),",
                  "        info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let _ = visitor_impl.visit(&nested_hir, visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let nested_hir = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Alternation(vec![",
                  "    Hir {",
                  "    kind: HirKind::Repetition(MockRepetition::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Group(MockGroup::new()),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: MockHirInfo::new(),",
                  "    };",
                  "    let mut visitor_impl = HeapVisitor::new();",
                  "    let result = visitor_impl.visit(&nested_hir, visitor);",
                  "    assert_eq!(visitor.visit_alternation_in_called, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:240:51\n    |\n240 |                         kind: HirKind::Repetition(MockRepetition::new()),\n    |                                                   ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:31\n    |\n241 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:244:46\n    |\n244 |                         kind: HirKind::Group(MockGroup::new()),\n    |                                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:245:31\n    |\n245 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:248:23\n    |\n248 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:15\n    |\n251 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:255:23\n    |\n255 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:259:26\n    |\n259 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:260:11\n    |\n260 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:265:31\n    |\n265 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:266:11\n    |\n266 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:269:26\n    |\n269 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:270:11\n    |\n270 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:273:11\n    |\n273 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:276:11\n    |\n276 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:240:51\n    |\n240 |                         kind: HirKind::Repetition(MockRepetition::new()),\n    |                                                   ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:31\n    |\n241 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:244:46\n    |\n244 |                         kind: HirKind::Group(MockGroup::new()),\n    |                                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:245:31\n    |\n245 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:248:23\n    |\n248 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:15\n    |\n251 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:255:23\n    |\n255 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:259:26\n    |\n259 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:260:11\n    |\n260 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:265:31\n    |\n265 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:266:11\n    |\n266 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:269:26\n    |\n269 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:270:11\n    |\n270 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:273:11\n    |\n273 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:276:11\n    |\n276 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:240:51\n    |\n240 |                         kind: HirKind::Repetition(MockRepetition::new()),\n    |                                                   ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:31\n    |\n241 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:244:46\n    |\n244 |                         kind: HirKind::Group(MockGroup::new()),\n    |                                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:245:31\n    |\n245 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:248:23\n    |\n248 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:15\n    |\n251 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:255:23\n    |\n255 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:259:26\n    |\n259 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:260:11\n    |\n260 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:265:31\n    |\n265 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:266:11\n    |\n266 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:269:26\n    |\n269 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:270:11\n    |\n270 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:273:11\n    |\n273 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:276:11\n    |\n276 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:240:51\n    |\n240 |                         kind: HirKind::Repetition(MockRepetition::new()),\n    |                                                   ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:31\n    |\n241 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:244:46\n    |\n244 |                         kind: HirKind::Group(MockGroup::new()),\n    |                                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:245:31\n    |\n245 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:248:23\n    |\n248 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:15\n    |\n251 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:255:23\n    |\n255 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:259:26\n    |\n259 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:260:11\n    |\n260 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:265:31\n    |\n265 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:266:11\n    |\n266 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:269:26\n    |\n269 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:270:11\n    |\n270 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:273:11\n    |\n273 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:276:11\n    |\n276 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:234:38\n    |\n234 |                 kind: HirKind::Group(MockGroup::new()),\n    |                                      ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:235:23\n    |\n235 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:240:51\n    |\n240 |                         kind: HirKind::Repetition(MockRepetition::new()),\n    |                                                   ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:241:31\n    |\n241 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:244:46\n    |\n244 |                         kind: HirKind::Group(MockGroup::new()),\n    |                                              ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:245:31\n    |\n245 |                         info: MockHirInfo::new(),\n    |                               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:248:23\n    |\n248 |                 info: MockHirInfo::new(),\n    |                       ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:251:15\n    |\n251 |         info: MockHirInfo::new(),\n    |               ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:255:23\n    |\n255 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:259:26\n    |\n259 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:260:11\n    |\n260 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockRepetition`\n   --> regex-syntax/src/hir/visitor.rs:265:31\n    |\n265 |     kind: HirKind::Repetition(MockRepetition::new()),\n    |                               ^^^^^^^^^^^^^^ use of undeclared type `MockRepetition`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:266:11\n    |\n266 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockGroup`\n   --> regex-syntax/src/hir/visitor.rs:269:26\n    |\n269 |     kind: HirKind::Group(MockGroup::new()),\n    |                          ^^^^^^^^^ use of undeclared type `MockGroup`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:270:11\n    |\n270 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:273:11\n    |\n273 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockHirInfo`\n   --> regex-syntax/src/hir/visitor.rs:276:11\n    |\n276 |     info: MockHirInfo::new(),\n    |           ^^^^^^^^^^^ use of undeclared type `MockHirInfo`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: visitor.visit_pre(hir)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct(hir) is true\n",
        "// constraint: visitor.visit_post(hir)? is Ok/Some\n",
        "// constraint: self.stack.pop() matches Some((post_hir, frame)) is true\n",
        "// constraint: let Some(x) = self.pop(frame) is true\n",
        "// constraint: let Frame::Alternation {..} = x is true\n",
        "// constraint: visitor.visit_alternation_in()? is Err/None\n"
      ],
      "input_infer": "visitor.call_count: 1-10, hir.kind: Repetition, Group, Concat with 1-5 elements, Alternation with 2-5 elements, self.stack.size: 1-3\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack.is_empty());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.finish_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_alternation_in_called);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.finish_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_alternation_in_called);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:231:48\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:235:48\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:231:48\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:235:48\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:231:48\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:235:48\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:231:48\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:235:48\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:231:48\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:235:48\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:231:48\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:235:48\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Repetition(Repetition::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Repetition(Repetition::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called_after_pre);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack.len() > 0);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack.last().is_some());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(matches!(heap_visitor.stack.last().unwrap().1, Frame::Alternation { .. }));"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_alternation_in_failed);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(matches!(heap_visitor.pop(last_frame).unwrap(), Frame::Alternation { .. }));"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.finish_called, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.start_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_pre_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_post_called_after_pre);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack.last().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(matches!(heap_visitor.stack.last().unwrap().1, Frame::Alternation { .. }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.visit_alternation_in_failed);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(matches!(heap_visitor.pop(last_frame).unwrap(), Frame::Alternation { .. }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut hir = Hir::new(HirKind::Group(Group::new()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.finish_called, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0425]: cannot find value `last_frame` in this scope\n   --> regex-syntax/src/hir/visitor.rs:237:39\n    |\n237 |     assert!(matches!(heap_visitor.pop(last_frame).unwrap(), Frame::Alternation { .. }));\n    |                                       ^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:231:43\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:235:43\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:231:24\n    |\n231 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n231 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:234:23\n    |\n234 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Group(Group::new()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Group(Group::new()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let hirs = vec![",
                "        Hir::new(HirKind::Repetition(Repetition::new())),",
                "        Hir::new(HirKind::Group(Group::new()))",
                "    ];",
                "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), visitor.get_last_error());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.start_called());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_pre_called(&hir));"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_post_called(&hir));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert_eq!(result.unwrap_err(), visitor.get_last_error());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.start_called());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_pre_called(&hir));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_post_called(&hir));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:95\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                                               ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Group(Group::new()))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:95\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                                               ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Group(Group::new()))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:95\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                                               ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Group(Group::new()))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:95\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                                               ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Group(Group::new()))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:95\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                                               ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Group(Group::new()))];\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Group(Group::new()))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let hirs = vec![",
                "        Hir::new(HirKind::Repetition(Repetition::new())),",
                "        Hir::new(HirKind::Group(Group::new()))",
                "    ];",
                "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.start_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.visit_pre_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.visit_post_called);"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(heap_visitor.stack.is_empty());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.visit_alternation_in_called);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.start_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.visit_pre_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.visit_post_called);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(heap_visitor.stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "    Hir::new(HirKind::Repetition(Repetition::new())),",
                  "    Hir::new(HirKind::Group(Group::new()))",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Alternation(hirs));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    assert!(visitor.visit_alternation_in_called);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:240:34\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:241:29\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |                             ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:10\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     Hir::ne(HirKind::Repetition(Repetition::new())),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:241:10\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n241 |     Hir::ne(HirKind::Group(Group::new()))\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:243:24\n    |\n243 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n243 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:240:34\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:241:29\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |                             ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:10\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     Hir::ne(HirKind::Repetition(Repetition::new())),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:241:10\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n241 |     Hir::ne(HirKind::Group(Group::new()))\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:243:24\n    |\n243 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n243 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:240:34\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:241:29\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |                             ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:10\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     Hir::ne(HirKind::Repetition(Repetition::new())),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:241:10\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n241 |     Hir::ne(HirKind::Group(Group::new()))\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:243:24\n    |\n243 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n243 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:240:34\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:241:29\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |                             ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:10\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     Hir::ne(HirKind::Repetition(Repetition::new())),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:241:10\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n241 |     Hir::ne(HirKind::Group(Group::new()))\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:243:24\n    |\n243 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n243 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:33\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |                                 ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:240:34\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:241:29\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |                             ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Group(Group::new()))\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Group(Group::new()))\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:10\n    |\n240 |     Hir::new(HirKind::Repetition(Repetition::new())),\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     Hir::ne(HirKind::Repetition(Repetition::new())),\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:241:10\n    |\n241 |     Hir::new(HirKind::Group(Group::new()))\n    |          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n241 |     Hir::ne(HirKind::Group(Group::new()))\n    |          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:243:24\n    |\n243 |     let mut hir = Hir::new(HirKind::Alternation(hirs));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n243 |     let mut hir = Hir::ne(HirKind::Alternation(hirs));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let hirs = vec![",
                "        Hir::new(HirKind::Repetition(Repetition::new())),",
                "        Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),",
                "    ];",
                "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_pre_called());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_post_called());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_alternation_in_called());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_pre_called());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_post_called());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![",
                  "        Hir::new(HirKind::Repetition(Repetition::new())),",
                  "        Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),",
                  "    ];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&mut hir, visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new();",
                  "    let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];",
                  "    let mut hir = Hir::new(HirKind::Concat(hirs.clone()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit(&mut hir, visitor);",
                  "    assert!(visitor.visit_alternation_in_called());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:68\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                                    ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:130\n    |\n239 | ...irKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                     ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                 ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))])),\n    |                                                 ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:111\n    |\n239 | ...ir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                           ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))]))];\n    |                                                                                                               ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:68\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                                    ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:130\n    |\n239 | ...irKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                     ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                 ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))])),\n    |                                                 ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:111\n    |\n239 | ...ir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                           ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))]))];\n    |                                                                                                               ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:68\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                                    ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:130\n    |\n239 | ...irKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                     ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                 ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))])),\n    |                                                 ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:111\n    |\n239 | ...ir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                           ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))]))];\n    |                                                                                                               ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:232:38\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |                                      ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:233:68\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                                    ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/hir/visitor.rs:239:50\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                  ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Repetition;\n    |\n225 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/visitor.rs:239:130\n    |\n239 | ...irKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                     ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n225 +    use ast::Group;\n    |\n225 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:230:23\n    |\n230 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:232:14\n    |\n232 |         Hir::new(HirKind::Repetition(Repetition::new())),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n232 |         Hir::ne(HirKind::Repetition(Repetition::new())),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:14\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |              ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:233:49\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))])),\n    |                                                 ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n233 |         Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))])),\n    |                                                 ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:235:24\n    |\n235 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n235 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/hir/visitor.rs:238:23\n    |\n238 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:26\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                          ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::ne(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                          ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:76\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::n...\n    |                                                                            ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::ne(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                                                            ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:239:111\n    |\n239 | ...ir::new(HirKind::Alternation(vec![Hir::new(HirKind::Group(Group::new()))]))];\n    |                                           ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n239 |     let hirs = vec![Hir::new(HirKind::Repetition(Repetition::new())), Hir::new(HirKind::Alternation(vec![Hir::ne(HirKind::Group(Group::new()))]))];\n    |                                                                                                               ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `hir::Hir` in the current scope\n   --> regex-syntax/src/hir/visitor.rs:240:24\n    |\n240 |     let mut hir = Hir::new(HirKind::Concat(hirs.clone()));\n    |                        ^^^ function or associated item not found in `hir::Hir`\n    |\n   ::: regex-syntax/src/hir/mod.rs:161:1\n    |\n161 | pub struct Hir {\n    | -------------- function or associated item `new` not found for this struct\n    |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n   --> regex-syntax/src/hir/mod.rs:219:5\n    |\n219 |     pub fn empty() -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259 |     pub fn class(class: Class) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275 |     pub fn anchor(anchor: Anchor) -> Hir {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name\n    |\n240 |     let mut hir = Hir::ne(HirKind::Concat(hirs.clone()));\n    |                        ~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: visitor.visit_pre(hir)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct(hir) is true\n",
        "// constraint: visitor.visit_post(hir)? is Ok/Some\n",
        "// constraint: self.stack.pop() matches Some((post_hir, frame)) is true\n",
        "// constraint: let Some(x) = self.pop(frame) is true\n",
        "// constraint: let Frame::Alternation {..} = x is true\n",
        "// constraint: visitor.visit_alternation_in()? is Ok/Some\n",
        "// constraint: visitor.visit_pre(hir)? is Err/None\n"
      ],
      "input_infer": "0 < hir_count <= 10, 0 < child_count <= 5, 1 <= repetitions <= 5, 1 <= groups <= 5, 1 <= alternations <= 5, 1 <= concatenations <= 5\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = DummyVisitor { ",
                "        invoked_pre: false, ",
                "        invoked_post: false, ",
                "        invoked_alternation: false ",
                "    };",
                "    let repetition = hir::Repetition { /* init fields */ };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_pre);"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_post);"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_alternation);"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(heap_visitor.stack.is_empty());"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert_eq!(heap_visitor.stack.len(), 0);"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(visitor.visit_pre(&hir).is_ok());"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(visitor.visit_post(&hir).is_ok());"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(visitor.visit_alternation_in().is_ok());"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(heap_visitor.stack.len() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_pre);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_post);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_alternation);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(heap_visitor.stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert_eq!(heap_visitor.stack.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(visitor.visit_pre(&hir).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(visitor.visit_post(&hir).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(visitor.visit_alternation_in().is_ok());",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let repetition = hir::Repetition { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(heap_visitor.stack.len() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:66\n    |\n268 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo { /* init fields */ } };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `greedy`, `hir` and `kind` in initializer of `hir::Repetition`\n   --> regex-syntax/src/hir/visitor.rs:267:22\n    |\n267 |     let repetition = hir::Repetition { /* init fields */ };\n    |                      ^^^^^^^^^^^^^^^ missing `greedy`, `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = DummyVisitor { ",
                "        invoked_pre: false, ",
                "        invoked_post: false, ",
                "        invoked_alternation: false ",
                "    };",
                "    let group = hir::Group { /* init fields */ };",
                "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_pre);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(!visitor.invoked_post);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_alternation);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_pre);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(!visitor.invoked_post);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let group = hir::Group { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_alternation);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:56\n    |\n268 |     let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };\n    |                                                        ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:273:56\n    |\n273 |     let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };\n    |                                                        ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `hir` and `kind` in initializer of `hir::Group`\n   --> regex-syntax/src/hir/visitor.rs:267:17\n    |\n267 |     let group = hir::Group { /* init fields */ };\n    |                 ^^^^^^^^^^ missing `hir` and `kind`\n\nerror[E0063]: missing fields `hir` and `kind` in initializer of `hir::Group`\n   --> regex-syntax/src/hir/visitor.rs:272:17\n    |\n272 |     let group = hir::Group { /* init fields */ };\n    |                 ^^^^^^^^^^ missing `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:56\n    |\n268 |     let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };\n    |                                                        ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:273:56\n    |\n273 |     let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };\n    |                                                        ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `hir` and `kind` in initializer of `hir::Group`\n   --> regex-syntax/src/hir/visitor.rs:267:17\n    |\n267 |     let group = hir::Group { /* init fields */ };\n    |                 ^^^^^^^^^^ missing `hir` and `kind`\n\nerror[E0063]: missing fields `hir` and `kind` in initializer of `hir::Group`\n   --> regex-syntax/src/hir/visitor.rs:272:17\n    |\n272 |     let group = hir::Group { /* init fields */ };\n    |                 ^^^^^^^^^^ missing `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:268:56\n    |\n268 |     let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };\n    |                                                        ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:273:56\n    |\n273 |     let hir = Hir { kind: HirKind::Group(group), info: HirInfo { /* init fields */ } };\n    |                                                        ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `hir` and `kind` in initializer of `hir::Group`\n   --> regex-syntax/src/hir/visitor.rs:267:17\n    |\n267 |     let group = hir::Group { /* init fields */ };\n    |                 ^^^^^^^^^^ missing `hir` and `kind`\n\nerror[E0063]: missing fields `hir` and `kind` in initializer of `hir::Group`\n   --> regex-syntax/src/hir/visitor.rs:272:17\n    |\n272 |     let group = hir::Group { /* init fields */ };\n    |                 ^^^^^^^^^^ missing `hir` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = DummyVisitor { ",
                "        invoked_pre: false, ",
                "        invoked_post: false, ",
                "        invoked_alternation: false ",
                "    };",
                "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                "    let concat = hir::Concat { /* init fields */ };",
                "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert!(!visitor.invoked_pre);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert!(!visitor.invoked_post);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert!(!visitor.invoked_alternation);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.stack.len(), 0);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.induct(&hir).is_some(), true);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.pop(frame).is_some(), true);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(visitor.visit_pre(&hir).is_ok(), true);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(visitor.visit_post(&hir).is_ok(), true);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(visitor.visit_alternation_in().is_ok(), true);"
                ],
                [
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.stack.len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert!(!visitor.invoked_pre);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert!(!visitor.invoked_post);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert!(!visitor.invoked_alternation);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.stack.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.induct(&hir).is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.pop(frame).is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(visitor.visit_pre(&hir).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(visitor.visit_post(&hir).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(visitor.visit_alternation_in().is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let concat = hir::Concat { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor {",
                  "    invoked_pre: false,",
                  "    invoked_post: false,",
                  "    invoked_alternation: false",
                  "    };",
                  "    assert_eq!(self.stack.len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:277:16\n    |\n260 | fn test_visit_130()\n    |    -------------- this function can't have a `self` parameter\n...\n277 |     assert_eq!(self.stack.len(), 0);\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0424, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:277:16\n    |\n260 | fn test_visit_131()\n    |    -------------- this function can't have a `self` parameter\n...\n277 |     assert_eq!(self.induct(&hir).is_some(), true);\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0424, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:277:16\n    |\n260 | fn test_visit_132()\n    |    -------------- this function can't have a `self` parameter\n...\n277 |     assert_eq!(self.pop(frame).is_some(), true);\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0425]: cannot find value `frame` in this scope\n   --> regex-syntax/src/hir/visitor.rs:277:25\n    |\n277 |     assert_eq!(self.pop(frame).is_some(), true);\n    |                         ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0424, E0425, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* init fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* init fields */ };\n268 +     let concat = Concat { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/hir/visitor.rs:277:16\n    |\n260 | fn test_visit_136()\n    |    -------------- this function can't have a `self` parameter\n...\n277 |     assert_eq!(self.stack.len(), 1);\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0424, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let visitor = DummyVisitor { ",
                "        invoked_pre: false, ",
                "        invoked_post: false, ",
                "        invoked_alternation: false ",
                "    };",
                "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                "    let alternation = hir::Alternation { /* init fields */ };",
                "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    heap_visitor.visit(&hir, visitor).unwrap();",
                  "    assert!(visitor.invoked_pre);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    heap_visitor.visit(&hir, visitor).unwrap();",
                  "    assert!(visitor.invoked_post);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    heap_visitor.visit(&hir, visitor).unwrap();",
                  "    assert!(visitor.invoked_alternation);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let alternation = hir::Alternation { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    heap_visitor.visit(&hir, visitor).unwrap();",
                  "    assert!(visitor.invoked_pre);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let alternation = hir::Alternation { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    heap_visitor.visit(&hir, visitor).unwrap();",
                  "    assert!(visitor.invoked_post);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let child_hir = Hir { /* Populate with valid Hir instance */ };",
                  "    let alternation = hir::Alternation { /* init fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    heap_visitor.visit(&hir, visitor).unwrap();",
                  "    assert!(visitor.invoked_alternation);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* init fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* init fields */ };\n268 +     let alternation = Alternation { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* init fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* init fields */ };\n268 +     let alternation = Alternation { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* init fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* init fields */ };\n268 +     let alternation = Alternation { /* init fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `info` and `kind` in initializer of `hir::Hir`\n   --> regex-syntax/src/hir/visitor.rs:267:21\n    |\n267 |     let child_hir = Hir { /* Populate with valid Hir instance */ };\n    |                     ^^^ missing `info` and `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let visitor = DummyVisitor { ",
                "        invoked_pre: false, ",
                "        invoked_post: false, ",
                "        invoked_alternation: false ",
                "    };",
                "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_pre);"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(!visitor.invoked_post);"
                ],
                [
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_alternation);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_pre);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(!visitor.invoked_post);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    assert!(visitor.invoked_alternation);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n268 +     let concat = Concat { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:273:23\n    |\n273 |     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n273 -     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n273 +     let concat = Concat { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:274:58\n    |\n274 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n268 +     let concat = Concat { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:273:23\n    |\n273 |     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n273 -     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n273 +     let concat = Concat { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:274:58\n    |\n274 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:23\n    |\n268 |     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n268 -     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n268 +     let concat = Concat { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:58\n    |\n269 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:273:23\n    |\n273 |     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n    |                       ^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Ast::Concat;\n    |\n225 +    use ast::Concat;\n    |\n225 +    use hir::HirKind::Concat;\n    |\n225 +    use hir::visitor::Frame::Concat;\n    |\nhelp: if you import `Concat`, refer to it directly\n    |\n273 -     let concat = hir::Concat { /* Initialize with empty or mismatched fields */ };\n273 +     let concat = Concat { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:274:58\n    |\n274 |     let hir = Hir { kind: HirKind::Concat(concat), info: HirInfo { /* init fields */ } };\n    |                                                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let visitor = DummyVisitor { ",
                "        invoked_pre: false, ",
                "        invoked_post: false, ",
                "        invoked_alternation: false ",
                "    };",
                "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit(&hir, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_pre);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_post);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_alternation);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit(&hir, visitor).is_err());"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.invoked_pre);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(!visitor.invoked_post);"
                ],
                [
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(!visitor.invoked_alternation);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_pre);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_post);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    assert!(!visitor.invoked_alternation);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit(&hir, visitor).is_err());",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(visitor.invoked_pre);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(!visitor.invoked_post);",
                  "}"
                ],
                [
                  "{",
                  "struct DummyVisitor {",
                  "    invoked_pre: bool,",
                  "    invoked_post: bool,",
                  "    invoked_alternation: bool,",
                  "}",
                  "",
                  "impl Visitor for DummyVisitor {",
                  "    type Output = ();",
                  "    type Err = ();",
                  "",
                  "    fn start(&mut self) {}",
                  "    ",
                  "    fn visit_pre(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_pre = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_post(&mut self, _: &Hir) -> Result<(), Self::Err> {",
                  "        self.invoked_post = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {",
                  "        self.invoked_alternation = true;",
                  "        Ok(())",
                  "    }",
                  "",
                  "    fn finish(self) -> Result<Self::Output, Self::Err> {",
                  "        Ok(())",
                  "    }",
                  "}",
                  "    let visitor = DummyVisitor { ",
                  "        invoked_pre: false, ",
                  "        invoked_post: false, ",
                  "        invoked_alternation: false ",
                  "    };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit(&hir, visitor);",
                  "    let mut visitor = DummyVisitor { invoked_pre: false, invoked_post: false, invoked_alternation: false };",
                  "    let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };",
                  "    let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(!visitor.invoked_alternation);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n268 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n268 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n268 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n268 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:273:28\n    |\n273 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n273 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n273 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:274:68\n    |\n274 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n268 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:273:28\n    |\n273 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n273 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n273 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:274:68\n    |\n274 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n268 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:273:28\n    |\n273 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n273 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n273 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:274:68\n    |\n274 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/visitor.rs:226:8\n    |\n226 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:268:28\n    |\n268 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n268 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n268 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:269:68\n    |\n269 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in module `hir`\n   --> regex-syntax/src/hir/visitor.rs:273:28\n    |\n273 |     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n    |                            ^^^^^^^^^^^ not found in `hir`\n    |\nhelp: consider importing one of these items\n    |\n225 +    use ast::Alternation;\n    |\n225 +    use ast::Ast::Alternation;\n    |\n225 +    use hir::HirKind::Alternation;\n    |\n225 +    use hir::visitor::Frame::Alternation;\n    |\nhelp: if you import `Alternation`, refer to it directly\n    |\n273 -     let alternation = hir::Alternation { /* Initialize with empty or mismatched fields */ };\n273 +     let alternation = Alternation { /* Initialize with empty or mismatched fields */ };\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/visitor.rs:274:68\n    |\n274 |     let hir = Hir { kind: HirKind::Alternation(alternation), info: HirInfo { /* init fields */ } };\n    |                                                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n225 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}