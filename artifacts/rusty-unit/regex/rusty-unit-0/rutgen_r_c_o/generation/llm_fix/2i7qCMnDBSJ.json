{
  "name": "regex_syntax::ast::ast::Ast::has_subexprs",
  "name_with_impl": "regex_syntax::ast::{impl#12}::has_subexprs",
  "mod_info": {
    "name": "ast",
    "loc": "regex-syntax/src/lib.rs:113:1:113:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/mod.rs:529:5:542:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *self matches Ast::Concat(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "Test input ranges: Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(0), end: Position(5) }, kind: LiteralKind::SomeKind, c: 'a' }), Ast::Class(Class::Unicode(ClassUnicode::SomeUnicode))] })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span {",
                "            start: Position(0),",
                "            end: Position(100),",
                "        },",
                "        asts: vec![",
                "            Ast::Literal(Literal {",
                "                span: Span {",
                "                    start: Position(0),",
                "                    end: Position(5),",
                "                },",
                "                kind: LiteralKind::SomeKind,",
                "                c: 'a',",
                "            }),",
                "            Ast::Class(Class::Unicode(ClassUnicode::SomeUnicode)),",
                "        ],",
                "    });",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(0), end: Position(5) }, kind: LiteralKind::SomeKind, c: 'a' }), Ast::Class(Class::Unicode(ClassUnicode::SomeUnicode))] });",
                  "    assert!(ast.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span {",
                  "            start: Position(0),",
                  "            end: Position(100),",
                  "        },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal {",
                  "                span: Span {",
                  "                    start: Position(0),",
                  "                    end: Position(5),",
                  "                },",
                  "                kind: LiteralKind::SomeKind,",
                  "                c: 'a',",
                  "            }),",
                  "            Ast::Class(Class::Unicode(ClassUnicode::SomeUnicode)),",
                  "        ],",
                  "    });",
                  "    ast.has_subexprs();",
                  "    let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(0), end: Position(5) }, kind: LiteralKind::SomeKind, c: 'a' }), Ast::Class(Class::Unicode(ClassUnicode::SomeUnicode))] });",
                  "    assert!(ast.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1528:20\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1528 |               start: Position(0),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:18\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |               end: Position(100),\n     |                    ^^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:28\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |                       start: Position(0),\n     |                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:26\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |                       end: Position(5),\n     |                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:36\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `SomeKind` not found for this enum\n...\n1537 |                 kind: LiteralKind::SomeKind,\n     |                                    ^^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no associated item named `SomeUnicode` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1540:53\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- associated item `SomeUnicode` not found for this struct\n...\n1540 |             Ast::Class(Class::Unicode(ClassUnicode::SomeUnicode)),\n     |                                                     ^^^^^^^^^^^ associated item not found in `ClassUnicode`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:56\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { ...\n     |                                                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:74\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { ...\n     |                                                                            ^^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:145\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(0), e...\n     |                                                                                                                                                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:163\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(0), end: Position(5) },...\n     |                                                                                                                                                                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1544:197\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `SomeKind` not found for this enum\n...\n1544 |     let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(0), end: Position(5) }, kind: LiteralKind::SomeKind, c...\n     |                                                                                                                                                                                                     ^^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no associated item named `SomeUnicode` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1544:258\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- associated item `SomeUnicode` not found for this struct\n...\n1544 |     let ast = Ast::Concat(Concat { span: Span { start: Position(0), end: Position(100) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(0), end: Position(5) }, kind: LiteralKind::SomeKind, c: 'a' }), Ast::Class(Class::Unicode(ClassUnicode::SomeUnicode))]...\n     |                                                                                                                                                                                                                                                                  ^^^^^^^^^^^ associated item not found in `ClassUnicode`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span {",
                "            start: Position(0),",
                "            end: Position(50),",
                "        },",
                "        asts: vec![",
                "            Ast::Literal(Literal {",
                "                span: Span {",
                "                    start: Position(0),",
                "                    end: Position(0),",
                "                },",
                "                kind: LiteralKind::SomeKind,",
                "                c: '\\0',",
                "            }),",
                "            Ast::Repetition(Repetition {",
                "                span: Span {",
                "                    start: Position(0),",
                "                    end: Position(10),",
                "                },",
                "                op: RepetitionOp::SomeOp,",
                "                greedy: true,",
                "                ast: Box::new(Ast::Empty(Span {",
                "                    start: Position(0),",
                "                    end: Position(0),",
                "                })),",
                "            }),",
                "        ],",
                "    });",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(50),",
                  "    },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(0),",
                  "    },",
                  "    kind: LiteralKind::SomeKind,",
                  "    c: '\\0',",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(10),",
                  "    },",
                  "    op: RepetitionOp::SomeOp,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Empty(Span {",
                  "    start: Position(0),",
                  "    end: Position(0),",
                  "    })),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span {",
                  "            start: Position(0),",
                  "            end: Position(50),",
                  "        },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal {",
                  "                span: Span {",
                  "                    start: Position(0),",
                  "                      end: Position { offset: 0, line: 0, column: 0 },  ",
                  "                },",
                  "                kind: LiteralKind::SomeKind,",
                  "                c: '\\0',",
                  "            }),",
                  "            Ast::Repetition(Repetition {",
                  "                span: Span {",
                  "                      start: Position { offset: 0, line: 0, column: 0 },  ",
                  "                      // Other fields should be initialized appropriately.  ",
                  "                      // Example values used here.  ",
                  "                    end: Position(10),",
                  "                },",
                  "                op: RepetitionOp::SomeOp,",
                  "                greedy: true,",
                  "                ast: Box::new(Ast::Empty(Span {",
                  "                    start: Position(0),",
                  "                    end: Position(0),",
                  "                })),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    ast.has_subexprs();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span {",
                  "      start: Position { offset: 0, line: 0, column: 0 },  ",
                  " ",
                  " ",
                  "    end: Position(50),",
                  "    },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(0),",
                  "    },",
                  "    kind: LiteralKind::SomeKind,",
                  "    c: '\\0',",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(10),",
                  "    },",
                  "    op: RepetitionOp::SomeOp,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Empty(Span {",
                  "    start: Position(0),",
                  "    end: Position(0),",
                  "    })),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1528:20\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1528 |               start: Position(0),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:18\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |               end: Position(50),\n     |                    ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:28\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |                       start: Position(0),\n     |                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:36\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `SomeKind` not found for this enum\n...\n1537 |                 kind: LiteralKind::SomeKind,\n     |                                    ^^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1545:26\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1545 |                       end: Position(10),\n     |                            ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no associated item named `SomeOp` found for struct `ast::RepetitionOp` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1547:35\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `SomeOp` not found for this struct\n...\n1547 |                 op: RepetitionOp::SomeOp,\n     |                                   ^^^^^^ associated item not found in `RepetitionOp`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1550:28\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1550 |                       start: Position(0),\n     |                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1551:26\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1551 |                       end: Position(0),\n     |                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1562:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1562 |       end: Position(50),\n     |            ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1567:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1567 |       start: Position(0),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1568:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1568 |       end: Position(0),\n     |            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1570:24\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `SomeKind` not found for this enum\n...\n1570 |     kind: LiteralKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1575:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1575 |       start: Position(0),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1576:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1576 |       end: Position(10),\n     |            ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no associated item named `SomeOp` found for struct `ast::RepetitionOp` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1578:23\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `SomeOp` not found for this struct\n...\n1578 |     op: RepetitionOp::SomeOp,\n     |                       ^^^^^^ associated item not found in `RepetitionOp`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1581:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1581 |       start: Position(0),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1582:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1582 |       end: Position(0),\n     |            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *self matches Ast::Alternation(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "1 <= test inputs <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let alternation = Alternation { span, asts: vec![] };",
                "    let ast = Ast::Alternation(alternation);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let alternation = Alternation { span, asts: vec![] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let alternation = Alternation { span, asts: vec![] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let alternation = Alternation { span, asts: vec![] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal)] };",
                "    let ast = Ast::Alternation(alternation);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert!(ast.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert!(ast.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1532:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1532 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let literal_a = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                "    let literal_b = Literal { span, kind: LiteralKind::Unicode('b'), c: 'b' };",
                "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal_a), Ast::Literal(literal_b)] };",
                "    let ast = Ast::Alternation(alternation);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let literal_a = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let literal_b = Literal { span, kind: LiteralKind::Unicode('b'), c: 'b' };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal_a), Ast::Literal(literal_b)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert!(ast.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 5, line: 0, column: 5 } };  ",
                  "    let literal_a = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let literal_b = Literal { span, kind: LiteralKind::Unicode('b'), c: 'b' };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal_a), Ast::Literal(literal_b)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let literal_a = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let literal_b = Literal { span, kind: LiteralKind::Unicode('b'), c: 'b' };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Literal(literal_a), Ast::Literal(literal_b)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert!(ast.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:56\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal_a = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:56\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1528 |     let literal_b = Literal { span, kind: LiteralKind::Unicode('b'), c: 'b' };\n     |                                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(5) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(5) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:56\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1533 |     let literal_a = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1534:56\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1534 |     let literal_b = Literal { span, kind: LiteralKind::Unicode('b'), c: 'b' };\n     |                                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(8) };",
                "    let repetition = Repetition { span, kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Ast::Dot(span)) };",
                "    let alternation = Alternation { span, asts: vec![Ast::Repetition(repetition)] };",
                "    let ast = Ast::Alternation(alternation);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(8) };",
                  "    let repetition = Repetition { span, kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Ast::Dot(span)) };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Repetition(repetition)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert!(ast.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 8, line: 0, column: 8 } };  ",
                  "    let repetition = Repetition { span, kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Ast::Dot(span)) };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Repetition(repetition)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(8) };",
                  "    let repetition = Repetition { span, kind: RepetitionKind::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };",
                  "    let alternation = Alternation { span, asts: vec![Ast::Repetition(repetition)] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    assert!(ast.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1527:41\n     |\n1527 |     let repetition = Repetition { span, kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Ast::Dot(span)) };\n     |                                         ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1527:89\n     |\n1527 |     let repetition = Repetition { span, kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Ast::Dot(span)) };\n     |                                                                                         ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(8) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(8) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1532:41\n     |\n1532 |     let repetition = Repetition { span, kind: RepetitionKind::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };\n     |                                         ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let inner_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode('x'), c: 'x' };",
                "    let inner_alternation = Alternation { span, asts: vec![Ast::Literal(inner_literal)] };",
                "    let outer_alternation = Alternation { span, asts: vec![Ast::Alternation(inner_alternation)] };",
                "    let ast = Ast::Alternation(outer_alternation);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let inner_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode('x'), c: 'x' };",
                  "    let inner_alternation = Alternation { span, asts: vec![Ast::Literal(inner_literal)] };",
                  "    let outer_alternation = Alternation { span, asts: vec![Ast::Alternation(inner_alternation)] };",
                  "    let ast = Ast::Alternation(outer_alternation);",
                  "    assert!(ast.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let inner_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode('x'), c: 'x' };",
                  "    let inner_alternation = Alternation { span, asts: vec![Ast::Literal(inner_literal)] };",
                  "    let outer_alternation = Alternation { span, asts: vec![Ast::Alternation(inner_alternation)] };",
                  "    let ast = Ast::Alternation(outer_alternation);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "      let inner_literal = Literal { span: Span { start: Position { offset: 1, line: 0, column: 0 }, end: Position { offset: 2, line: 0, column: 0 } }, kind: LiteralKind::Unicode('x'), c: 'x' };",
                  "    let inner_alternation = Alternation { span, asts: vec![Ast::Literal(inner_literal)] };",
                  "    let outer_alternation = Alternation { span, asts: vec![Ast::Alternation(inner_alternation)] };",
                  "    let ast = Ast::Alternation(outer_alternation);",
                  "    assert!(ast.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(10) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(10) };\n     |                                                  ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:55\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |       let inner_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode('x'), c: 'x' };\n     |                                                         ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:73\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |       let inner_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode('x'), c: 'x' };\n     |                                                                           ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:107\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let inner_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode('x'), c: 'x' };\n     |                                                                                                           ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(10) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(10) };\n     |                                                  ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:171\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1533 |       let inner_literal = Literal { span: Span { start: Position { offset: 1, line: 0, column: 0 }, end: Position { offset: 2, line: 0, column: 0 } }, kind: LiteralKind::Unicode('x...\n     |                                                                                                                                                                           ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *self matches Ast::Group(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "test input ranges: Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Repetition(Repetition { span: Span { start: Position(1), end: Position(5) }, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c: 'a' })) })) })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Group(Group {",
                "        span: Span {",
                "            start: Position(0),",
                "            end: Position(10),",
                "        },",
                "        kind: GroupKind::Capturing,",
                "        hir: Box::new(Ast::Repetition(Repetition {",
                "            span: Span {",
                "                start: Position(1),",
                "                end: Position(5),",
                "            },",
                "            op: RepetitionOp::Star,",
                "            greedy: true,",
                "            ast: Box::new(Ast::Literal(Literal {",
                "                span: Span {",
                "                    start: Position(2),",
                "                    end: Position(3),",
                "                },",
                "                kind: LiteralKind::Unicode,",
                "                c: 'a',",
                "            })),",
                "        })),",
                "    });",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Group(Group {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(10),",
                  "    },",
                  "    kind: GroupKind::Capturing,",
                  "    hir: Box::new(Ast::Repetition(Repetition {",
                  "    span: Span {",
                  "    start: Position(1),",
                  "    end: Position(5),",
                  "    },",
                  "    op: RepetitionOp::Star,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal {",
                  "    span: Span {",
                  "    start: Position(2),",
                  "    end: Position(3),",
                  "    },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    })),",
                  "    })),",
                  "    });",
                  "    assert!(ast.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span {",
                  "              start: Position { offset: 0, line: 0, column: 0 },  ",
                  "            end: Position(10),",
                  "        },",
                  "        kind: GroupKind::Capturing,",
                  "        hir: Box::new(Ast::Repetition(Repetition {",
                  "            span: Span {",
                  "                start: Position(1),",
                  "                end: Position(5),",
                  "            },",
                  "            op: RepetitionOp::Star,",
                  "            greedy: true,",
                  "            ast: Box::new(Ast::Literal(Literal {",
                  "                span: Span {",
                  "                    start: Position(2),",
                  "                    end: Position(3),",
                  "                },",
                  "                kind: LiteralKind::Unicode,",
                  "                c: 'a',",
                  "            })),",
                  "        })),",
                  "    });",
                  "    ast.has_subexprs();",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(10),",
                  "    },",
                  "    kind: GroupKind::Capturing,",
                  "    hir: Box::new(Ast::Repetition(Repetition {",
                  "    span: Span {",
                  "    start: Position(1),",
                  "    end: Position(5),",
                  "    },",
                  "    op: RepetitionOp::Star,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal {",
                  "    span: Span {",
                  "      start: Position { offset: 2, line: 0, column: 0 },  ",
                  "      end: Position { offset: 3, line: 0, column: 0 },",
                  "",
                  "",
                  "",
                  "",
                  "    },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    })),",
                  "    })),",
                  "    });",
                  "    assert!(ast.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:18\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |               end: Position(10),\n     |                    ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:26\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1531 |         kind: GroupKind::Capturing,\n     |                          ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1531 |         kind: GroupKind::NonCapturing,\n     |                          ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1532:9\n     |\n1532 |         hir: Box::new(Ast::Repetition(Repetition {\n     |         ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:24\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |                   start: Position(1),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:22\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |                   end: Position(5),\n     |                        ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no associated item named `Star` found for struct `ast::RepetitionOp` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:31\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `Star` not found for this struct\n...\n1537 |             op: RepetitionOp::Star,\n     |                               ^^^^ associated item not found in `RepetitionOp`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:28\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |                       start: Position(2),\n     |                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1542:26\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1542 |                       end: Position(3),\n     |                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1544:36\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1544 |                 kind: LiteralKind::Unicode,\n     |                                    ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1552:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1552 |       start: Position(0),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1553:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1553 |       end: Position(10),\n     |            ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1555:22\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1555 |     kind: GroupKind::Capturing,\n     |                      ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1555 |     kind: GroupKind::NonCapturing,\n     |                      ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1556:5\n     |\n1556 |     hir: Box::new(Ast::Repetition(Repetition {\n     |     ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       start: Position(1),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1559:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1559 |       end: Position(5),\n     |            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no associated item named `Star` found for struct `ast::RepetitionOp` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1561:23\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `Star` not found for this struct\n...\n1561 |     op: RepetitionOp::Star,\n     |                       ^^^^ associated item not found in `RepetitionOp`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1572:24\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1572 |     kind: LiteralKind::Unicode,\n     |                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Group(Group {",
                "        span: Span {",
                "            start: Position(0),",
                "            end: Position(10),",
                "        },",
                "        kind: GroupKind::Capturing,",
                "        hir: Box::new(Ast::Alternation(Alternation {",
                "            span: Span {",
                "                start: Position(1),",
                "                end: Position(9),",
                "            },",
                "            asts: vec![",
                "                Ast::Literal(Literal {",
                "                    span: Span {",
                "                        start: Position(2),",
                "                        end: Position(3),",
                "                    },",
                "                    kind: LiteralKind::Unicode,",
                "                    c: 'b',",
                "                }),",
                "                Ast::Literal(Literal {",
                "                    span: Span {",
                "                        start: Position(4),",
                "                        end: Position(5),",
                "                    },",
                "                    kind: LiteralKind::Unicode,",
                "                    c: 'c',",
                "                }),",
                "            ],",
                "        })),",
                "    });",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c: 'b' }), Ast::Literal(Literal { span: Span { start: Position(4), end: Position(5) }, kind: LiteralKind::Unicode, c: 'c' })] })) });",
                  "    assert!(ast.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span {",
                  "              start: Position { offset: 0, line: 0, column: 0 },  ",
                  "            end: Position(10),",
                  "        },",
                  "        kind: GroupKind::Capturing,",
                  "        hir: Box::new(Ast::Alternation(Alternation {",
                  "            span: Span {",
                  "                start: Position(1),",
                  "                end: Position(9),",
                  "            },",
                  "            asts: vec![",
                  "                Ast::Literal(Literal {",
                  "                    span: Span {",
                  "                        start: Position(2),",
                  "                        end: Position(3),",
                  "                    },",
                  "                    kind: LiteralKind::Unicode,",
                  "                    c: 'b',",
                  "                }),",
                  "                Ast::Literal(Literal {",
                  "                    span: Span {",
                  "                        start: Position(4),",
                  "                        end: Position(5),",
                  "                    },",
                  "                    kind: LiteralKind::Unicode,",
                  "                    c: 'c',",
                  "                }),",
                  "            ],",
                  "        })),",
                  "    });",
                  "    ast.has_subexprs();",
                  "    let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c: 'b' }), Ast::Literal(Literal { span: Span { start: Position(4), end: Position(5) }, kind: LiteralKind::Unicode, c: 'c' })] })) });",
                  "    assert!(ast.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:18\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |               end: Position(10),\n     |                    ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:26\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1531 |         kind: GroupKind::Capturing,\n     |                          ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1531 |         kind: GroupKind::NonCapturing,\n     |                          ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1532:9\n     |\n1532 |         hir: Box::new(Ast::Alternation(Alternation {\n     |         ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:24\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |                   start: Position(1),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:22\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |                   end: Position(9),\n     |                        ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1540:32\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1540 |                           start: Position(2),\n     |                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |                           end: Position(3),\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1543:40\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1543 |                     kind: LiteralKind::Unicode,\n     |                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1548:32\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1548 |                           start: Position(4),\n     |                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1549 |                           end: Position(5),\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:40\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1551 |                     kind: LiteralKind::Unicode,\n     |                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:54\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alt...\n     |                                                        ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:72\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alt...\n     |                                                                          ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1558:105\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1558 |     let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alt...\n     |                                                                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1558 |     let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::NonCapturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c: 'b' }), Ast::Literal(Literal { span: Span { start: Position(4), end: Position(5) }, kind: LiteralKind::Unicode, c: 'c' })] })) });\n     |                                                                                                         ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1558:116\n     |\n1558 | ...: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Posit...\n     |                                                  ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:181\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), e...\n     |                                                                                                                                                                                       ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:199\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) },...\n     |                                                                                                                                                                                                         ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:268\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), e...\n     |                                                                                                                                                                                                                                                                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:286\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) },...\n     |                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1558:320\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1558 |     let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c...\n     |                                                                                                                                                                                                                                                                                                                                ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:383\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c: 'b' }), Ast::Literal(Literal { span: Span { start: Position(4), e...\n     |                                                                                                                                                                                                                                                                                                                                                                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1558:401\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1558 |       let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c: 'b' }), Ast::Literal(Literal { span: Span { start: Position(4), end: Position(5) },...\n     |                                                                                                                                                                                                                                                                                                                                                                                                                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1558:435\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1558 |     let ast = Ast::Group(Group { span: Span { start: Position(0), end: Position(10) }, kind: GroupKind::Capturing, hir: Box::new(Ast::Alternation(Alternation { span: Span { start: Position(1), end: Position(9) }, asts: vec![Ast::Literal(Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Unicode, c: 'b' }), Ast::Literal(Literal { span: Span { start: Position(4), end: Position(5) }, kind: LiteralKind::Unicode, c...\n     |                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Group(Group {",
                "        span: Span {",
                "            start: Position(0),",
                "            end: Position(10),",
                "        },",
                "        kind: GroupKind::Capturing,",
                "        hir: Box::new(Ast::Concat(Concat {",
                "            span: Span {",
                "                start: Position(1),",
                "                end: Position(9),",
                "            },",
                "            asts: vec![",
                "                Ast::Literal(Literal {",
                "                    span: Span {",
                "                        start: Position(2),",
                "                        end: Position(3),",
                "                    },",
                "                    kind: LiteralKind::Unicode,",
                "                    c: 'd',",
                "                }),",
                "                Ast::Literal(Literal {",
                "                    span: Span {",
                "                        start: Position(4),",
                "                        end: Position(5),",
                "                    },",
                "                    kind: LiteralKind::Unicode,",
                "                    c: 'e',",
                "                }),",
                "            ],",
                "        })),",
                "    });",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Group(Group {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "    end: Position(10),",
                  "    },",
                  "    kind: GroupKind::Capturing,",
                  "    hir: Box::new(Ast::Concat(Concat {",
                  "    span: Span {",
                  "    start: Position(1),",
                  "    end: Position(9),",
                  "    },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal {",
                  "    span: Span {",
                  "    start: Position(2),",
                  "    end: Position(3),",
                  "    },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'd',",
                  "    }),",
                  "    Ast::Literal(Literal {",
                  "    span: Span {",
                  "    start: Position(4),",
                  "    end: Position(5),",
                  "    },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'e',",
                  "    }),",
                  "    ],",
                  "    })),",
                  "    });",
                  "    assert!(ast.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span {",
                  "            start: Position(0),",
                  "            end: Position(10),",
                  "        },",
                  "        kind: GroupKind::Capturing,",
                  "        hir: Box::new(Ast::Concat(Concat {",
                  "            span: Span {",
                  "                start: Position(1),",
                  "                end: Position(9),",
                  "            },",
                  "            asts: vec![",
                  "                Ast::Literal(Literal {",
                  "                    span: Span {",
                  "                          start: Position { offset: 2, line: 0, column: 0 },  ",
                  "                        end: Position(3),",
                  "                    },",
                  "                    kind: LiteralKind::Unicode,",
                  "                    c: 'd',",
                  "                }),",
                  "                Ast::Literal(Literal {",
                  "                    span: Span {",
                  "                        start: Position(4),",
                  "                        end: Position(5),",
                  "                    },",
                  "                    kind: LiteralKind::Unicode,",
                  "                    c: 'e',",
                  "                }),",
                  "            ],",
                  "        })),",
                  "    });",
                  "    ast.has_subexprs();",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span {",
                  "    start: Position(0),",
                  "      end: Position { offset: 10, line: 0, column: 0 },  ",
                  "    },",
                  "    kind: GroupKind::Capturing,",
                  "    hir: Box::new(Ast::Concat(Concat {",
                  "    span: Span {",
                  "      start: Position { offset: 1, line: 0, column: 0 },  ",
                  "    end: Position(9),",
                  "    },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal {",
                  "    span: Span {",
                  "    start: Position(2),",
                  "    end: Position(3),",
                  "    },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'd',",
                  "    }),",
                  "    Ast::Literal(Literal {",
                  "    span: Span {",
                  "    start: Position(4),",
                  "    end: Position(5),",
                  "    },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'e',",
                  "    }),",
                  "    ],",
                  "    })),",
                  "    });",
                  "    assert!(ast.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1528:20\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1528 |               start: Position(0),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:18\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |               end: Position(10),\n     |                    ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:26\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1531 |         kind: GroupKind::Capturing,\n     |                          ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1531 |         kind: GroupKind::NonCapturing,\n     |                          ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1532:9\n     |\n1532 |         hir: Box::new(Ast::Concat(Concat {\n     |         ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:24\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |                   start: Position(1),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:22\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |                   end: Position(9),\n     |                        ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |                           end: Position(3),\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1543:40\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1543 |                     kind: LiteralKind::Unicode,\n     |                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1548:32\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1548 |                           start: Position(4),\n     |                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1549 |                           end: Position(5),\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:40\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1551 |                     kind: LiteralKind::Unicode,\n     |                                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1560:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1560 |       start: Position(0),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1563:22\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1563 |     kind: GroupKind::Capturing,\n     |                      ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1563 |     kind: GroupKind::NonCapturing,\n     |                      ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1564:5\n     |\n1564 |     hir: Box::new(Ast::Concat(Concat {\n     |     ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1567:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1567 |       end: Position(9),\n     |            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1572:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1572 |       start: Position(2),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1573:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1573 |       end: Position(3),\n     |            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1575:24\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1575 |     kind: LiteralKind::Unicode,\n     |                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1580:12\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1580 |       start: Position(4),\n     |              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1581:10\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1581 |       end: Position(5),\n     |            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1583:24\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1583 |     kind: LiteralKind::Unicode,\n     |                        ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *self matches Ast::Repetition(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "Ast::Repetition(Repetition { kind: ..., greedy: ..., hir: Box::new(...) }) with valid inner Ast values\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inner_ast = Ast::Empty(Span { start: Position, end: Position });",
                "    let repetition = Repetition { ",
                "        kind: RepetitionKind, ",
                "        greedy: true,",
                "        hir: Box::new(inner_ast) ",
                "    };",
                "    let ast = Ast::Repetition(repetition);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let inner_ast = Ast::Empty(Span { start: Position, end: Position });",
                  "    let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(inner_ast) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert!(ast.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let inner_ast = Ast::Empty(Span { start: Position, end: Position });",
                  "    let repetition = Repetition { ",
                  "        kind: RepetitionKind, ",
                  "        greedy: true,",
                  "        hir: Box::new(inner_ast) ",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ast.has_subexprs();",
                  "    let inner_ast = Ast::Empty(Span { start: Position, end: Position });",
                  "    let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(inner_ast) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert!(ast.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:46\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let inner_ast = Ast::Empty(Span { start: Position, end: Position });\n     |                                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:61\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let inner_ast = Ast::Empty(Span { start: Position, end: Position });\n     |                                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1528:15\n     |\n1528 |         kind: RepetitionKind, \n     |               ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1528 |         kind: ast::RepetitionKind::OneOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: ast::RepetitionKind::ZeroOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: ast::RepetitionKind::ZeroOrOne, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1528 |         kind: (ast::RepetitionKind::Range(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:46\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |       let inner_ast = Ast::Empty(Span { start: Position, end: Position });\n     |                                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:61\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |       let inner_ast = Ast::Empty(Span { start: Position, end: Position });\n     |                                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1535:41\n     |\n1535 |     let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(inner_ast) };\n     |                                         ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1535 |     let repetition = Repetition { kind: ast::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(inner_ast) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1535 |     let repetition = Repetition { kind: ast::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(inner_ast) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1535 |     let repetition = Repetition { kind: ast::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(inner_ast) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1535 |     let repetition = Repetition { kind: (ast::RepetitionKind::Range(/* fields */)), greedy: true, hir: Box::new(inner_ast) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1528:9\n     |\n1528 |         kind: RepetitionKind, \n     |         ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1530:9\n     |\n1530 |         hir: Box::new(inner_ast) \n     |         ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1535:35\n     |\n1535 |     let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(inner_ast) };\n     |                                   ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1535:71\n     |\n1535 |     let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(inner_ast) };\n     |                                                                       ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'a' });",
                "    let repetition = Repetition { ",
                "        kind: RepetitionKind, ",
                "        greedy: false,",
                "        hir: Box::new(inner_ast) ",
                "    };",
                "    let ast = Ast::Repetition(repetition);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'a' });",
                  "    let repetition = Repetition { kind: RepetitionKind, greedy: false, hir: Box::new(inner_ast) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'a' });",
                  "    let repetition = Repetition { ",
                  "        kind: RepetitionKind, ",
                  "        greedy: false,",
                  "        hir: Box::new(inner_ast) ",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ast.has_subexprs();",
                  "      let inner_ast = Ast::Literal(Literal { span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }, kind: LiteralKind, c: 'a' });  ",
                  "    let repetition = Repetition { op: RepetitionKind, greedy: false, ast: Box::new(inner_ast) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:64\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'a' });\n     |                                                                  ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:79\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'a' });\n     |                                                                                 ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `LiteralKind`\n    --> regex-syntax/src/ast/mod.rs:1526:97\n     |\n1526 |     let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'a' });\n     |                                                                                                 ^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | / pub enum LiteralKind {\n639  | |     /// The literal is written verbatim, e.g., `a` or ``.\n640  | |     Verbatim,\n641  | |     /// The literal is written as an escape because it is punctuation, e.g.,\n...    |\n656  | |     Special(SpecialLiteralKind),\n657  | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1526 |     let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Octal, c: 'a' });\n     |                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~\n1526 |     let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Punctuation, c: 'a' });\n     |                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1526 |     let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Verbatim, c: 'a' });\n     |                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variants are also available\n     |\n1526 |     let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::HexBrace(/* fields */)), c: 'a' });\n     |                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1526 |     let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::HexFixed(/* fields */)), c: 'a' });\n     |                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1526 |     let inner_ast = Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::Special(/* fields */)), c: 'a' });\n     |                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1528:15\n     |\n1528 |         kind: RepetitionKind, \n     |               ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1528 |         kind: ast::RepetitionKind::OneOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: ast::RepetitionKind::ZeroOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: ast::RepetitionKind::ZeroOrOne, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1528 |         kind: (ast::RepetitionKind::Range(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found enum `LiteralKind`\n    --> regex-syntax/src/ast/mod.rs:1534:167\n     |\n1534 | ... }, end: Position { offset: 0, line: 0, column: 0 } }, kind: LiteralKind, c: 'a' });  \n     |                                                                 ^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | / pub enum LiteralKind {\n639  | |     /// The literal is written verbatim, e.g., `a` or ``.\n640  | |     Verbatim,\n641  | |     /// The literal is written as an escape because it is punctuation, e.g.,\n...    |\n656  | |     Special(SpecialLiteralKind),\n657  | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1534 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }, kind: ast::LiteralKind::Octal, c: 'a' });  \n     |                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~\n1534 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }, kind: ast::LiteralKind::Punctuation, c: 'a' });  \n     |                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1534 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }, kind: ast::LiteralKind::Verbatim, c: 'a' });  \n     |                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variants are also available\n     |\n1534 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }, kind: (ast::LiteralKind::HexBrace(/* fields */)), c: 'a' });  \n     |                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1534 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }, kind: (ast::LiteralKind::HexFixed(/* fields */)), c: 'a' });  \n     |                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1534 |       let inner_ast = Ast::Literal(Literal { span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }, kind: (ast::LiteralKind::Special(/* fields */)), c: 'a' });  \n     |                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1535:39\n     |\n1535 |     let repetition = Repetition { op: RepetitionKind, greedy: false, ast: Box::new(inner_ast) };\n     |                                       ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1535 |     let repetition = Repetition { op: ast::RepetitionKind::OneOrMore, greedy: false, ast: Box::new(inner_ast) };\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1535 |     let repetition = Repetition { op: ast::RepetitionKind::ZeroOrMore, greedy: false, ast: Box::new(inner_ast) };\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1535 |     let repetition = Repetition { op: ast::RepetitionKind::ZeroOrOne, greedy: false, ast: Box::new(inner_ast) };\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1535 |     let repetition = Repetition { op: (ast::RepetitionKind::Range(/* fields */)), greedy: false, ast: Box::new(inner_ast) };\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1528:9\n     |\n1528 |         kind: RepetitionKind, \n     |         ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1530:9\n     |\n1530 |         hir: Box::new(inner_ast) \n     |         ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0063]: missing field `span` in initializer of `ast::Repetition`\n    --> regex-syntax/src/ast/mod.rs:1535:22\n     |\n1535 |     let repetition = Repetition { op: RepetitionKind, greedy: false, ast: Box::new(inner_ast) };\n     |                      ^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0560.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inner_ast = Ast::Dot(Span { start: Position, end: Position });",
                "    let repetition = Repetition { ",
                "        kind: RepetitionKind, ",
                "        greedy: true,",
                "        hir: Box::new(inner_ast) ",
                "    };",
                "    let ast = Ast::Repetition(repetition);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let inner_ast = Ast::Dot(Span { start: Position, end: Position });",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind,",
                  "    greedy: true,",
                  "    hir: Box::new(inner_ast)",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert!(ast.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let inner_ast = Ast::Dot(Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } });",
                  "    let repetition = Repetition { ",
                  "        kind: RepetitionKind, ",
                  "        greedy: true,",
                  "        hir: Box::new(inner_ast) ",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ast.has_subexprs();",
                  "    let inner_ast = Ast::Dot(Span { start: Position, end: Position });",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind,",
                  "    greedy: true,",
                  "    hir: Box::new(inner_ast)",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert!(ast.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1528:15\n     |\n1528 |         kind: RepetitionKind, \n     |               ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1528 |         kind: ast::RepetitionKind::OneOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: ast::RepetitionKind::ZeroOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: ast::RepetitionKind::ZeroOrOne, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1528 |         kind: (ast::RepetitionKind::Range(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:44\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |       let inner_ast = Ast::Dot(Span { start: Position, end: Position });\n     |                                              ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1534:59\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1534 |       let inner_ast = Ast::Dot(Span { start: Position, end: Position });\n     |                                                             ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1536:11\n     |\n1536 |     kind: RepetitionKind,\n     |           ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1536 |     kind: ast::RepetitionKind::OneOrMore,\n     |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1536 |     kind: ast::RepetitionKind::ZeroOrMore,\n     |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1536 |     kind: ast::RepetitionKind::ZeroOrOne,\n     |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1536 |     kind: (ast::RepetitionKind::Range(/* fields */)),\n     |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1528:9\n     |\n1528 |         kind: RepetitionKind, \n     |         ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1530:9\n     |\n1530 |         hir: Box::new(inner_ast) \n     |         ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1536:5\n     |\n1536 |     kind: RepetitionKind,\n     |     ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1538:5\n     |\n1538 |     hir: Box::new(inner_ast)\n     |     ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inner_group = Group { ",
                "        span: Span { start: Position, end: Position }, ",
                "        kind: GroupKind, ",
                "        ast: Box::new(Ast::Empty(Span { start: Position, end: Position })) ",
                "    };",
                "    let repetition = Repetition { ",
                "        kind: RepetitionKind, ",
                "        greedy: true,",
                "        hir: Box::new(Ast::Group(inner_group)) ",
                "    };",
                "    let ast = Ast::Repetition(repetition);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let inner_group = Group { span: Span { start: Position, end: Position }, kind: GroupKind, ast: Box::new(Ast::Empty(Span { start: Position, end: Position })) };",
                  "    let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(Ast::Group(inner_group)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let inner_group = Group { ",
                  "                  span: Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } },  ",
                  "        kind: GroupKind, ",
                  "          ast: Box::new(Ast::Empty(Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } }))  ",
                  "    };",
                  "    let repetition = Repetition { ",
                  "        kind: RepetitionKind, ",
                  "        greedy: true,",
                  "        hir: Box::new(Ast::Group(inner_group)) ",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ast.has_subexprs();",
                  "    let inner_group = Group { span: Span { start: Position, end: Position }, kind: GroupKind, ast: Box::new(Ast::Empty(Span { start: Position, end: Position })) };",
                  "    let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(Ast::Group(inner_group)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found enum `GroupKind`\n    --> regex-syntax/src/ast/mod.rs:1528:15\n     |\n1528 |         kind: GroupKind, \n     |               ^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | / pub enum GroupKind {\n1234 | |     /// `(a)`\n1235 | |     CaptureIndex(u32),\n1236 | |     /// `(?P<name>a)`\n...    |\n1239 | |     NonCapturing(Flags),\n1240 | | }\n     | |_^\nhelp: the following enum variants are available\n     |\n1528 |         kind: (ast::GroupKind::CaptureIndex(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: (ast::GroupKind::CaptureName(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         kind: (ast::GroupKind::NonCapturing(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1532:15\n     |\n1532 |         kind: RepetitionKind, \n     |               ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1532 |         kind: ast::RepetitionKind::OneOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1532 |         kind: ast::RepetitionKind::ZeroOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1532 |         kind: ast::RepetitionKind::ZeroOrOne, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1532 |         kind: (ast::RepetitionKind::Range(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:51\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let inner_group = Group { span: Span { start: Position, end: Position }, kind: GroupKind, ast: Box::new(Ast::Empty(Span { start: Posi...\n     |                                                     ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:66\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let inner_group = Group { span: Span { start: Position, end: Position }, kind: GroupKind, ast: Box::new(Ast::Empty(Span { start: Posi...\n     |                                                                    ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `GroupKind`\n    --> regex-syntax/src/ast/mod.rs:1538:84\n     |\n1538 |     let inner_group = Group { span: Span { start: Position, end: Position }, kind: GroupKind, ast: Box::new(Ast::Empty(Span { start: Posi...\n     |                                                                                    ^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | / pub enum GroupKind {\n1234 | |     /// `(a)`\n1235 | |     CaptureIndex(u32),\n1236 | |     /// `(?P<name>a)`\n...    |\n1239 | |     NonCapturing(Flags),\n1240 | | }\n     | |_^\nhelp: the following enum variants are available\n     |\n1538 |     let inner_group = Group { span: Span { start: Position, end: Position }, kind: (ast::GroupKind::CaptureIndex(/* fields */)), ast: Box::new(Ast::Empty(Span { start: Position, end: Position })) };\n     |                                                                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1538 |     let inner_group = Group { span: Span { start: Position, end: Position }, kind: (ast::GroupKind::CaptureName(/* fields */)), ast: Box::new(Ast::Empty(Span { start: Position, end: Position })) };\n     |                                                                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1538 |     let inner_group = Group { span: Span { start: Position, end: Position }, kind: (ast::GroupKind::NonCapturing(/* fields */)), ast: Box::new(Ast::Empty(Span { start: Position, end: Position })) };\n     |                                                                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:134\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let inner_group = Group { span: Span { start: Position, end: Position }, kind: GroupKind, ast: Box::new(Ast::Empty(Span { start: Position, e...\n     |                                                                                                                                        ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:149\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let inner_group = Group { span: Span { start: Position, end: Position }, kind: GroupKind, ast: Box::new(Ast::Empty(Span { start: Position, end: Position })...\n     |                                                                                                                                                       ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1539:41\n     |\n1539 |     let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(Ast::Group(inner_group)) };\n     |                                         ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1539 |     let repetition = Repetition { kind: ast::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Ast::Group(inner_group)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1539 |     let repetition = Repetition { kind: ast::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Ast::Group(inner_group)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1539 |     let repetition = Repetition { kind: ast::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Ast::Group(inner_group)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1539 |     let repetition = Repetition { kind: (ast::RepetitionKind::Range(/* fields */)), greedy: true, hir: Box::new(Ast::Group(inner_group)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1532:9\n     |\n1532 |         kind: RepetitionKind, \n     |         ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1534:9\n     |\n1534 |         hir: Box::new(Ast::Group(inner_group)) \n     |         ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1539:35\n     |\n1539 |     let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(Ast::Group(inner_group)) };\n     |                                   ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1539:71\n     |\n1539 |     let repetition = Repetition { kind: RepetitionKind, greedy: true, hir: Box::new(Ast::Group(inner_group)) };\n     |                                                                       ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inner_alternation = Alternation { ",
                "        span: Span { start: Position, end: Position }, ",
                "        asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] ",
                "    };",
                "    let repetition = Repetition { ",
                "        kind: RepetitionKind, ",
                "        greedy: false,",
                "        hir: Box::new(Ast::Alternation(inner_alternation)) ",
                "    };",
                "    let ast = Ast::Repetition(repetition);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] };",
                  "    let repetition = Repetition { kind: RepetitionKind, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let inner_alternation = Alternation { ",
                  "        span: Span { start: Position, end: Position }, ",
                  "        asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] ",
                  "    };",
                  "    let repetition = Repetition { ",
                  "        kind: RepetitionKind, ",
                  "        greedy: false,",
                  "        hir: Box::new(Ast::Alternation(inner_alternation)) ",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ast.has_subexprs();",
                  "    let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] };",
                  "    let repetition = Repetition { kind: RepetitionKind, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:29\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |           span: Span { start: Position, end: Position }, \n     |                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:44\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |           span: Span { start: Position, end: Position }, \n     |                                              ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1528:63\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1528 |           asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] \n     |                                                                 ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1528:78\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1528 |           asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] \n     |                                                                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `LiteralKind`\n    --> regex-syntax/src/ast/mod.rs:1528:96\n     |\n1528 |         asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] \n     |                                                                                                ^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | / pub enum LiteralKind {\n639  | |     /// The literal is written verbatim, e.g., `a` or ``.\n640  | |     Verbatim,\n641  | |     /// The literal is written as an escape because it is punctuation, e.g.,\n...    |\n656  | |     Special(SpecialLiteralKind),\n657  | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1528 |         asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Octal, c: 'b' })] \n     |                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Punctuation, c: 'b' })] \n     |                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Verbatim, c: 'b' })] \n     |                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variants are also available\n     |\n1528 |         asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::HexBrace(/* fields */)), c: 'b' })] \n     |                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::HexFixed(/* fields */)), c: 'b' })] \n     |                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1528 |         asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::Special(/* fields */)), c: 'b' })] \n     |                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1531:15\n     |\n1531 |         kind: RepetitionKind, \n     |               ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1531 |         kind: ast::RepetitionKind::OneOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1531 |         kind: ast::RepetitionKind::ZeroOrMore, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1531 |         kind: ast::RepetitionKind::ZeroOrOne, \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1531 |         kind: (ast::RepetitionKind::Range(/* fields */)), \n     |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1537:63\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1537 |       let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { s...\n     |                                                                 ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1537:78\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1537 |       let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { s...\n     |                                                                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1537:144\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1537 |       let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, e...\n     |                                                                                                                                                  ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1537:159\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1537 |       let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position },...\n     |                                                                                                                                                                 ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found enum `LiteralKind`\n    --> regex-syntax/src/ast/mod.rs:1537:177\n     |\n1537 | ...teral { span: Span { start: Position, end: Position }, kind: LiteralKind, c: 'b' })] };\n     |                                                                 ^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | / pub enum LiteralKind {\n639  | |     /// The literal is written verbatim, e.g., `a` or ``.\n640  | |     Verbatim,\n641  | |     /// The literal is written as an escape because it is punctuation, e.g.,\n...    |\n656  | |     Special(SpecialLiteralKind),\n657  | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1537 |     let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Octal, c: 'b' })] };\n     |                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~\n1537 |     let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Punctuation, c: 'b' })] };\n     |                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1537 |     let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: ast::LiteralKind::Verbatim, c: 'b' })] };\n     |                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variants are also available\n     |\n1537 |     let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::HexBrace(/* fields */)), c: 'b' })] };\n     |                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1537 |     let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::HexFixed(/* fields */)), c: 'b' })] };\n     |                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1537 |     let inner_alternation = Alternation { span: Span { start: Position, end: Position }, asts: vec![Ast::Literal(Literal { span: Span { start: Position, end: Position }, kind: (ast::LiteralKind::Special(/* fields */)), c: 'b' })] };\n     |                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected value, found enum `RepetitionKind`\n    --> regex-syntax/src/ast/mod.rs:1538:41\n     |\n1538 |     let repetition = Repetition { kind: RepetitionKind, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };\n     |                                         ^^^^^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:1150:1\n     |\n1150 | / pub enum RepetitionKind {\n1151 | |     /// `?`\n1152 | |     ZeroOrOne,\n1153 | |     /// `*`\n...    |\n1158 | |     Range(RepetitionRange),\n1159 | | }\n     | |_^\nhelp: you might have meant to use one of the following enum variants\n     |\n1538 |     let repetition = Repetition { kind: ast::RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1538 |     let repetition = Repetition { kind: ast::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1538 |     let repetition = Repetition { kind: ast::RepetitionKind::ZeroOrOne, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: alternatively, the following enum variant is available\n     |\n1538 |     let repetition = Repetition { kind: (ast::RepetitionKind::Range(/* fields */)), greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1531:9\n     |\n1531 |         kind: RepetitionKind, \n     |         ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1533:9\n     |\n1533 |         hir: Box::new(Ast::Alternation(inner_alternation)) \n     |         ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1538:35\n     |\n1538 |     let repetition = Repetition { kind: RepetitionKind, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };\n     |                                   ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1538:72\n     |\n1538 |     let repetition = Repetition { kind: RepetitionKind, greedy: false, hir: Box::new(Ast::Alternation(inner_alternation)) };\n     |                                                                        ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `span`, `op`, `ast`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *self matches Ast::Class(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "Class::Unicode, Class::Perl, Class::Bracketed\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unicode_class = Ast::Class(Class::Unicode(ClassUnicode {}));",
                "    unicode_class.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode_class = Ast::Class(Class::Unicode(ClassUnicode {}));",
                  "    assert_eq!(unicode_class.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let unicode_class = Ast::Class(Class::Unicode(ClassUnicode {}));",
                  "    unicode_class.has_subexprs();",
                  "    let unicode_class = Ast::Class(Class::Unicode(ClassUnicode {}));",
                  "    assert_eq!(unicode_class.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ast::ClassUnicode`\n    --> regex-syntax/src/ast/mod.rs:1526:51\n     |\n1526 |     let unicode_class = Ast::Class(Class::Unicode(ClassUnicode {}));\n     |                                                   ^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ast::ClassUnicode`\n    --> regex-syntax/src/ast/mod.rs:1528:51\n     |\n1528 |     let unicode_class = Ast::Class(Class::Unicode(ClassUnicode {}));\n     |                                                   ^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let perl_class = Ast::Class(Class::Perl(ClassPerl {}));",
                "    perl_class.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let perl_class = Ast::Class(Class::Perl(ClassPerl {}));",
                  "    assert!(perl_class.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let perl_class = Ast::Class(Class::Perl(ClassPerl {}));",
                  "    perl_class.has_subexprs();",
                  "    let perl_class = Ast::Class(Class::Perl(ClassPerl {}));",
                  "    assert!(perl_class.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ast::ClassPerl`\n    --> regex-syntax/src/ast/mod.rs:1526:45\n     |\n1526 |     let perl_class = Ast::Class(Class::Perl(ClassPerl {}));\n     |                                             ^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ast::ClassPerl`\n    --> regex-syntax/src/ast/mod.rs:1528:45\n     |\n1528 |     let perl_class = Ast::Class(Class::Perl(ClassPerl {}));\n     |                                             ^^^^^^^^^ missing `kind`, `negated` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bracketed_class = Ast::Class(Class::Bracketed(ClassBracketed {}));",
                "    bracketed_class.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let bracketed_class = Ast::Class(Class::Bracketed(ClassBracketed {}));",
                  "    assert_eq!(bracketed_class.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let bracketed_class = Ast::Class(Class::Bracketed(ClassBracketed {}));",
                  "    bracketed_class.has_subexprs();",
                  "    let bracketed_class = Ast::Class(Class::Bracketed(ClassBracketed {}));",
                  "    assert_eq!(bracketed_class.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ast::ClassBracketed`\n    --> regex-syntax/src/ast/mod.rs:1526:55\n     |\n1526 |     let bracketed_class = Ast::Class(Class::Bracketed(ClassBracketed {}));\n     |                                                       ^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ast::ClassBracketed`\n    --> regex-syntax/src/ast/mod.rs:1528:55\n     |\n1528 |     let bracketed_class = Ast::Class(Class::Bracketed(ClassBracketed {}));\n     |                                                       ^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *self matches Ast::Assertion(_) is true\n",
        "// constraint: *self matches Ast::Literal(_) or Ast::Empty(_) or Ast::Flags(_) or Ast::Assertion(_) or Ast::Dot(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "The test input ranges are: Ast::Assertion(_), Ast::Empty(_), Ast::Flags(_), Ast::Dot(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let ast = Ast::Empty(span);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let ast = Ast::Empty(span);",
                  "    assert!(!ast.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let ast = Ast::Empty(span);",
                  "    assert!(!ast.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let flags = Flags::new(); // Assuming a suitable constructor exists",
                "    let set_flags = SetFlags { span, flags };",
                "    let ast = Ast::Flags(set_flags);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let flags = Flags::new();",
                  "    let set_flags = SetFlags { span, flags };",
                  "    let ast = Ast::Flags(set_flags);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let flags = Flags::new(); // Assuming a suitable constructor exists",
                  "    let set_flags = SetFlags { span, flags };",
                  "    let ast = Ast::Flags(set_flags);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let flags = Flags::new();",
                  "    let set_flags = SetFlags { span, flags };",
                  "    let ast = Ast::Flags(set_flags);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(5) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(5) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:24\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1527 |     let flags = Flags::new(); // Assuming a suitable constructor exists\n     |                        ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(5) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(5) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1532:24\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1532 |     let flags = Flags::new();\n     |                        ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let ast = Ast::Dot(span);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })] });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };  ",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };  ",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "     let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };  ",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })] });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1539 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1539 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1539 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:55\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `new` not found for this struct\n...\n1545 |     let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                       ^^^ function or associated item not found in `ClassUnicode`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1539 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:55\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `new` not found for this struct\n...\n1545 |     let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                       ^^^ function or associated item not found in `ClassUnicode`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1548:50\n     |\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1548:92\n     |\n1548 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:154\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                                          ^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1539 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:55\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `new` not found for this struct\n...\n1545 |     let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                       ^^^ function or associated item not found in `ClassUnicode`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1548:50\n     |\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1548:92\n     |\n1548 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:154\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                                          ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char,...\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1551:71\n     |\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char,...\n     |                                                                       ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:133\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                     ^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1539 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:55\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `new` not found for this struct\n...\n1545 |     let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                       ^^^ function or associated item not found in `ClassUnicode`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1548:50\n     |\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1548:92\n     |\n1548 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:154\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                                          ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char,...\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1551:71\n     |\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char,...\n     |                                                                       ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:133\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                     ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1553:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1553 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1553:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1553 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1554:111\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1554 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Liter...\n     |                                                                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1554:176\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1554 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                                                                ^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `SomeKind` not found for this enum\n...\n1530 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::SomeKind });\n     |                                                                     ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1533 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' });\n     |                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1539 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:55\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `new` not found for this struct\n...\n1545 |     let ast = Ast::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                       ^^^ function or associated item not found in `ClassUnicode`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1548:50\n     |\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kin...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1548:92\n     |\n1548 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1548:154\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1548 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                                          ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char,...\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' })) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1551:71\n     |\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char,...\n     |                                                                       ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1551:133\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1551 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), hir: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                     ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1553:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1553 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1553:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1553 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1554:111\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1554 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Liter...\n     |                                                                                                               ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1554:176\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1554 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                                                                ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1556:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1556 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1556:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1556 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1557:101\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1557 |     let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal...\n     |                                                                                                     ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Char` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1557:166\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n...\n1557 |     let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }), Ast::Literal(Literal { span, kind: LiteralKind::Char, c...\n     |                                                                                                                                                                      ^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters",
                "    let ast = Ast::Literal(literal);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span_empty = Span { start: Position(0), end: Position(0) };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    assert_eq!(ast_empty.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span_empty = Span { start: Position(0), end: Position(0) };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position(0), end: Position(3) };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    assert_eq!(ast_flags.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span_empty = Span { start: Position(0), end: Position(0) };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position(0), end: Position(3) };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    let span_dot = Span { start: Position(0), end: Position(1) };",
                  "    let ast_dot = Ast::Dot(span_dot);",
                  "    assert_eq!(ast_dot.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span_empty = Span { start: Position(0), end: Position(0) };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position(0), end: Position(3) };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    let span_dot = Span { start: Position(0), end: Position(1) };",
                  "    let ast_dot = Ast::Dot(span_dot);",
                  "    let assertion = Assertion { span: Span { start: Position(0), end: Position(1) }, kind: AssertionKind::Begin };",
                  "    let ast_assertion = Ast::Assertion(assertion);",
                  "    assert_eq!(ast_assertion.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };  ",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "      let span_empty = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    assert_eq!(ast_empty.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };  ",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "      let span_empty = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "      let span_flags = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 3, line: 0, column: 0 } };  ",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    assert_eq!(ast_flags.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span_empty = Span { start: Position(0), end: Position(0) };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position(0), end: Position(3) };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    let span_dot = Span { start: Position(0), end: Position(1) };",
                  "    let ast_dot = Ast::Dot(span_dot);",
                  "    assert_eq!(ast_dot.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };  ",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span_empty = Span { start: Position(0), end: Position(0) };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "      let span_flags = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 3, line: 0, column: 0 } };  ",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    let span_dot = Span { start: Position(0), end: Position(1) };",
                  "    let ast_dot = Ast::Dot(span_dot);",
                  "    let assertion = Assertion { span: Span { start: Position(0), end: Position(1) }, kind: AssertionKind::Begin };",
                  "    let ast_assertion = Ast::Assertion(assertion);",
                  "    assert_eq!(ast_assertion.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:60\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1536 |     let flags = SetFlags { span: span_flags, flags: Flags::new() };\n     |                                                            ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1533:36\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1533 |       let span_empty = Span { start: Position(0), end: Position(0) };\n     |                                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1533:54\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1533 |       let span_empty = Span { start: Position(0), end: Position(0) };\n     |                                                        ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:36\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span_flags = Span { start: Position(0), end: Position(3) };\n     |                                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:54\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span_flags = Span { start: Position(0), end: Position(3) };\n     |                                                        ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:60\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1536 |     let flags = SetFlags { span: span_flags, flags: Flags::new() };\n     |                                                            ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:34\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span_dot = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:52\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span_dot = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }; // Assuming suitable kinds and characters\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1533:36\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1533 |       let span_empty = Span { start: Position(0), end: Position(0) };\n     |                                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1533:54\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1533 |       let span_empty = Span { start: Position(0), end: Position(0) };\n     |                                                        ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:60\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1536 |     let flags = SetFlags { span: span_flags, flags: Flags::new() };\n     |                                                            ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:34\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span_dot = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:52\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span_dot = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1540:53\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1540 |       let assertion = Assertion { span: Span { start: Position(0), end: Position(1) }, kind: AssertionKind::Begin };\n     |                                                       ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1540:71\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1540 |       let assertion = Assertion { span: Span { start: Position(0), end: Position(1) }, kind: AssertionKind::Begin };\n     |                                                                         ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Begin` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1540:107\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Begin` not found for this enum\n...\n1540 |     let assertion = Assertion { span: Span { start: Position(0), end: Position(1) }, kind: AssertionKind::Begin };\n     |                                                                                                           ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let assertion = Assertion { span, kind: AssertionKind::Start }; // Assuming suitable kinds",
                "    let ast = Ast::Assertion(assertion);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::Start };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::Start }; // Assuming suitable kinds",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::Start };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1527 |     let assertion = Assertion { span, kind: AssertionKind::Start }; // Assuming suitable kinds\n     |                                                            ^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1531 |     let assertion = Assertion { span, kind: AssertionKind::Start };\n     |                                                            ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *self matches Ast::Dot(_) is true\n",
        "// constraint: *self matches Ast::Literal(_) or Ast::Empty(_) or Ast::Flags(_) or Ast::Assertion(_) or Ast::Dot(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "Ast::Dot(_), Ast::Literal(_), Ast::Empty(_), Ast::Flags(_), Ast::Assertion(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                "    let ast = Ast::Dot(span);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    assert_eq!(ast_empty.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::default() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    assert_eq!(ast_flags.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::default() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    let span_assertion = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let assertion = Assertion { span: span_assertion, kind: AssertionKind::Boundary };",
                  "    let ast_assertion = Ast::Assertion(assertion);",
                  "    assert_eq!(ast_assertion.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    assert_eq!(ast_empty.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::default() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    assert_eq!(ast_flags.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast_empty = Ast::Empty(span_empty);",
                  "    let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let flags = SetFlags { span: span_flags, flags: Flags::default() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    let span_assertion = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let assertion = Assertion { span: span_assertion, kind: AssertionKind::Boundary };",
                  "    let ast_assertion = Ast::Assertion(assertion);",
                  "    assert_eq!(ast_assertion.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1529:41\n     |\n1529 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1529:69\n     |\n1529 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0560`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:47\n     |\n1528 |     let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                               ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:75\n     |\n1528 |     let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                           ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:47\n     |\n1528 |     let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                               ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:75\n     |\n1528 |     let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                           ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:47\n     |\n1530 |     let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                               ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:75\n     |\n1530 |     let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                           ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:60\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1531 |     let flags = SetFlags { span: span_flags, flags: Flags::default() };\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:47\n     |\n1528 |     let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                               ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:75\n     |\n1528 |     let span_empty = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                           ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:47\n     |\n1530 |     let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                               ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:75\n     |\n1530 |     let span_flags = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                           ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:60\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1531 |     let flags = SetFlags { span: span_flags, flags: Flags::default() };\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1533:51\n     |\n1533 |     let span_assertion = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                   ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1533:79\n     |\n1533 |     let span_assertion = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                               ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Boundary` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1534:76\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Boundary` not found for this enum\n...\n1534 |     let assertion = Assertion { span: span_assertion, kind: AssertionKind::Boundary };\n     |                                                                            ^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                "    let ast = Ast::Literal(literal);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Dot(span);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1524 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:41\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:69\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1528 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1524 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:41\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:69\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1528 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                "    let ast = Ast::Empty(span);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });",
                  "    assert_eq!(ast.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Empty(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Dot(span);",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });",
                  "    assert_eq!(ast.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:41\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:69\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:41\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:69\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:41\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:69\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `StartOfLine` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1535:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `StartOfLine` not found for this enum\n...\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });\n     |                                                                     ^^^^^^^^^^^ variant or associated item not found in `AssertionKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n     |                                                                     ~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:41\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:69\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:41\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:69\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `StartOfLine` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1535:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `StartOfLine` not found for this enum\n...\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });\n     |                                                                     ^^^^^^^^^^^ variant or associated item not found in `AssertionKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n     |                                                                     ~~~~~~~~~\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:41\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1537:50\n     |\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1537:92\n     |\n1537 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:128\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                                                                                ^^^^^^^ associated item not found in `Literal`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:41\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:69\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:41\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:69\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `StartOfLine` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1535:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `StartOfLine` not found for this enum\n...\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });\n     |                                                                     ^^^^^^^^^^^ variant or associated item not found in `AssertionKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n     |                                                                     ~~~~~~~~~\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:41\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1537:50\n     |\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1537:92\n     |\n1537 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:128\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                                                                                ^^^^^^^ associated item not found in `Literal`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1538:41\n     |\n1538 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1538:69\n     |\n1538 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1539:71\n     |\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                                       ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:107\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                                                                           ^^^^^^^ associated item not found in `Literal`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 27 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:41\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:69\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:41\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:69\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `StartOfLine` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1535:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `StartOfLine` not found for this enum\n...\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });\n     |                                                                     ^^^^^^^^^^^ variant or associated item not found in `AssertionKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n     |                                                                     ~~~~~~~~~\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:41\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1537:50\n     |\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1537:92\n     |\n1537 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:128\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                                                                                ^^^^^^^ associated item not found in `Literal`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1538:41\n     |\n1538 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1538:69\n     |\n1538 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1539:71\n     |\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                                       ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:107\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                                                                           ^^^^^^^ associated item not found in `Literal`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1540:41\n     |\n1540 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1540:69\n     |\n1540 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1541:85\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1541 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });\n     |                                                                                     ^^^^^^^ associated item not found in `Literal`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1541:122\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1541 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });\n     |                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:41\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1526:69\n     |\n1526 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:41\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1528:69\n     |\n1528 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:41\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1530:69\n     |\n1530 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1531 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:41\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1532:69\n     |\n1532 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:41\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1534:69\n     |\n1534 |     let span = Span { start: Position { index: 0 }, end: Position { index: 0 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `StartOfLine` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1535:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `StartOfLine` not found for this enum\n...\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartOfLine });\n     |                                                                     ^^^^^^^^^^^ variant or associated item not found in `AssertionKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1535 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n     |                                                                     ~~~~~~~~~\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:41\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1536 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1537:50\n     |\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1537:92\n     |\n1537 | ..., kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1537:128\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1537 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Literal(Literal::Unicode('a...\n     |                                                                                                                                ^^^^^^^ associated item not found in `Literal`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1538:41\n     |\n1538 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1538:69\n     |\n1538 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0560]: struct `ast::Group` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1539:71\n     |\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                                       ^^^ `ast::Group` does not have this field\n     |\n     = note: available fields are: `ast`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:107\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1539 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(0), hir: Box::new(Ast::Literal(Literal::Unicode('a'))) });\n     |                                                                                                           ^^^^^^^ associated item not found in `Literal`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1540:41\n     |\n1540 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1540:69\n     |\n1540 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1541:85\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1541 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });\n     |                                                                                     ^^^^^^^ associated item not found in `Literal`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1541:122\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1541 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });\n     |                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1542:41\n     |\n1542 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1542:69\n     |\n1542 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1543:75\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1543 |     let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });\n     |                                                                           ^^^^^^^ associated item not found in `Literal`\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1543:112\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1543 |     let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal::Unicode('a')), Ast::Literal(Literal::Unicode('b'))] });\n     |                                                                                                                ^^^^^^^ associated item not found in `Literal`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };",
                "    let flags = SetFlags { span, flags: Flags::new() };",
                "    let ast = Ast::Flags(flags);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };",
                  "    let flags = SetFlags { span, flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };",
                  "    let flags = SetFlags { span, flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };",
                  "    let flags = SetFlags { span, flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:48\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1524 |     let flags = SetFlags { span, flags: Flags::new() };\n     |                                                ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:41\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:69\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 3 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:48\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1528 |     let flags = SetFlags { span, flags: Flags::new() };\n     |                                                ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                "    let assertion = Assertion { span, kind: AssertionKind::Start };",
                "    let ast = Ast::Assertion(assertion);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let assertion = Assertion { span, kind: AssertionKind::Start };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(!ast.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let assertion = Assertion { span, kind: AssertionKind::Start };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };",
                  "    let assertion = Assertion { span, kind: AssertionKind::Start };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(!ast.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:41\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1523:69\n     |\n1523 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1524 |     let assertion = Assertion { span, kind: AssertionKind::Start };\n     |                                                            ^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:41\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                         ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0560]: struct `ast::Position` has no field named `index`\n    --> regex-syntax/src/ast/mod.rs:1527:69\n     |\n1527 |     let span = Span { start: Position { index: 0 }, end: Position { index: 1 } };\n     |                                                                     ^^^^^ `ast::Position` does not have this field\n     |\n     = note: available fields are: `offset`, `line`, `column`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1528 |     let assertion = Assertion { span, kind: AssertionKind::Start };\n     |                                                            ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *self matches Ast::Literal(_) is true\n",
        "// constraint: *self matches Ast::Literal(_) or Ast::Empty(_) or Ast::Flags(_) or Ast::Assertion(_) or Ast::Dot(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "Ast::Literal(_) with various Unicode and byte values; Ast::Empty(Span) with start and end positions; Ast::Flags(SetFlags) with valid flags; Ast::Assertion(Assertion) with valid kinds; Ast::Dot(Span) with valid spans.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                "    literal.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(literal.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    literal.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(literal.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1524 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Byte(97), c: 'a' });",
                "    literal.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Byte(97), c: 'a' });",
                  "    assert_eq!(literal.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Byte(97), c: 'a' });",
                  "    literal.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Byte(97), c: 'a' });",
                  "    assert_eq!(literal.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n...\n1524 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Byte(97), c: 'a' });\n     |                                                                   ^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n...\n1527 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Byte(97), c: 'a' });\n     |                                                                   ^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let empty = Ast::Empty(span);",
                "    empty.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(empty.has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Flags(span).has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }).has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Dot(span).has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Assertion(Assertion { span, kind: AssertionKind::Start }).has_subexprs(), false);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Class(Class::Unicode(ClassUnicode::Any)).has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Repetition(Repetition { span, kind: RepetitionKind::Plus, greedy: true, hir: Box::new(empty) }).has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Group(Group { span, kind: GroupKind::Capturing, ast: Box::new(empty) }).has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Alternation(Alternation { span, asts: vec![empty] }).has_subexprs(), true);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Concat(Concat { span, asts: vec![empty] }).has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(empty.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Flags(span).has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }).has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Dot(span).has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Assertion(Assertion { span, kind: AssertionKind::Start }).has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Class(Class::Unicode(ClassUnicode::Any)).has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Repetition(Repetition { span, kind: RepetitionKind::Plus, greedy: true, hir: Box::new(empty) }).has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Group(Group { span, kind: GroupKind::Capturing, ast: Box::new(empty) }).has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Alternation(Alternation { span, asts: vec![empty] }).has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let empty = Ast::Empty(span);",
                  "    empty.has_subexprs();",
                  "    assert_eq!(Ast::Concat(Concat { span, asts: vec![empty] }).has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1529:27\n     |\n1529 |     assert_eq!(Ast::Flags(span).has_subexprs(), false);\n     |                ---------- ^^^^ expected `SetFlags`, found `Span`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:64\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1529 |     assert_eq!(Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' }).has_subexprs(), false);\n     |                                                                ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:70\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1529 |     assert_eq!(Ast::Assertion(Assertion { span, kind: AssertionKind::Start }).has_subexprs(), false);\n     |                                                                      ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no associated item named `Any` found for struct `ast::ClassUnicode` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:56\n     |\n837  | pub struct ClassUnicode {\n     | ----------------------- associated item `Any` not found for this struct\n...\n1529 |     assert_eq!(Ast::Class(Class::Unicode(ClassUnicode::Any)).has_subexprs(), true);\n     |                                                        ^^^ associated item not found in `ClassUnicode`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1529:51\n     |\n1529 |     assert_eq!(Ast::Repetition(Repetition { span, kind: RepetitionKind::Plus, greedy: true, hir: Box::new(empty) }).has_subexprs(), true);\n     |                                                   ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Plus` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:73\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Plus` not found for this enum\n...\n1529 |     assert_eq!(Ast::Repetition(Repetition { span, kind: RepetitionKind::Plus, greedy: true, hir: Box::new(empty) }).has_subexprs(), true);\n     |                                                                         ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1529:93\n     |\n1529 |     assert_eq!(Ast::Repetition(Repetition { span, kind: RepetitionKind::Plus, greedy: true, hir: Box::new(empty) }).has_subexprs(), true);\n     |                                                                                             ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:58\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1529 |     assert_eq!(Ast::Group(Group { span, kind: GroupKind::Capturing, ast: Box::new(empty) }).has_subexprs(), true);\n     |                                                          ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1529 |     assert_eq!(Ast::Group(Group { span, kind: GroupKind::NonCapturing, ast: Box::new(empty) }).has_subexprs(), true);\n     |                                                          ~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let flags = SetFlags { span, flags: Flags::default() };",
                "    let flags_ast = Ast::Flags(flags);",
                "    flags_ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let flags_ast = Ast::Flags(flags);",
                  "    assert_eq!(flags_ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let flags_ast = Ast::Flags(flags);",
                  "    flags_ast.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let flags_ast = Ast::Flags(flags);",
                  "    assert_eq!(flags_ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:48\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1524 |     let flags = SetFlags { span, flags: Flags::default() };\n     |                                                ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1527 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1527 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:48\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1528 |     let flags = SetFlags { span, flags: Flags::default() };\n     |                                                ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                "    let assertion_ast = Ast::Assertion(assertion);",
                "    assertion_ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let assertion_ast = Ast::Assertion(assertion);",
                  "    assertion_ast.has_subexprs() == false;"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let assertion_ast = Ast::Assertion(assertion);",
                  "    assertion_ast.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let assertion_ast = Ast::Assertion(assertion);",
                  "    assertion_ast.has_subexprs() == false;",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1527 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1527 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let dot = Ast::Dot(span);",
                "    dot.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!literal.has_subexprs());"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!empty.has_subexprs());"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!flags.has_subexprs());"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!assertion.has_subexprs());"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(dot.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let dot = Ast::Dot(span);",
                  "    dot.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!literal.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let dot = Ast::Dot(span);",
                  "    dot.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!empty.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let dot = Ast::Dot(span);",
                  "    dot.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!flags.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let dot = Ast::Dot(span);",
                  "    dot.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(!assertion.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let dot = Ast::Dot(span);",
                  "    dot.has_subexprs();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let empty = Ast::Empty(span);",
                  "    let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    assert!(dot.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:59\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:75\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1530 |     let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });\n     |                                                                           ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:59\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:75\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1530 |     let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });\n     |                                                                           ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:59\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:75\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1530 |     let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });\n     |                                                                           ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:59\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:75\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1530 |     let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });\n     |                                                                           ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1523:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1523 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:40\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                        ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1526:66\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n...\n1526 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                                  ^^^^^^^ function or associated item not found in `Position`\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:67\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1527 |     let literal = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                   ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:59\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1529 |     let flags = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1530:75\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1530 |     let assertion = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });\n     |                                                                           ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *self matches Ast::Flags(_) is true\n",
        "// constraint: *self matches Ast::Literal(_) or Ast::Empty(_) or Ast::Flags(_) or Ast::Assertion(_) or Ast::Dot(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "Ast::Flags(flags), Ast::Literal(literal), Ast::Empty(span), Ast::Assertion(assertion), or Ast::Dot(span) where flags, literal, span, and assertion are valid instances according to their respective definitions.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let ast = Ast::Empty(span);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let ast = Ast::Empty(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                "    let ast = Ast::Literal(literal);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1524 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1528 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let assertion = Assertion { span, kind: AssertionKind::BeginLine };",
                "    let ast = Ast::Assertion(assertion);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::BeginLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::BeginLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::BeginLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `BeginLine` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `BeginLine` not found for this enum\n...\n1524 |     let assertion = Assertion { span, kind: AssertionKind::BeginLine };\n     |                                                            ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1527:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1527 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `BeginLine` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `BeginLine` not found for this enum\n...\n1528 |     let assertion = Assertion { span, kind: AssertionKind::BeginLine };\n     |                                                            ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let ast = Ast::Dot(span);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Dot(span), Ast::Dot(span)] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Dot(span), Ast::Dot(span)] });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Dot(span), Ast::Dot(span)] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Dot(span), Ast::Dot(span)] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Dot(span), Ast::Dot(span)] });",
                  "    let result = ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Dot(span), Ast::Dot(span)] });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1533 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1533 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Beginning` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Beginning` not found for this enum\n...\n1536 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });\n     |                                                                     ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1533 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Beginning` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Beginning` not found for this enum\n...\n1536 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });\n     |                                                                     ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1539 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1533 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Beginning` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Beginning` not found for this enum\n...\n1536 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });\n     |                                                                     ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1539 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1542:50\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1542:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1542:92\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                                            ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1533 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Beginning` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Beginning` not found for this enum\n...\n1536 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });\n     |                                                                     ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1539 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1542:50\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1542:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1542:92\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                                            ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1545 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1545 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(1), ast: Box::new(Ast::Dot(span)) });\n     |                                                         ~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1533 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Beginning` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Beginning` not found for this enum\n...\n1536 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });\n     |                                                                     ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1539 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1542:50\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1542:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1542:92\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                                            ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1545 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1545 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(1), ast: Box::new(Ast::Dot(span)) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n...\n1533 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::default() });\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Beginning` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1536:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Beginning` not found for this enum\n...\n1536 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Beginning });\n     |                                                                     ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1538:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1538 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1539:63\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1539 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                               ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1541:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1541 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0560]: struct `ast::Repetition` has no field named `kind`\n    --> regex-syntax/src/ast/mod.rs:1542:50\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                  ^^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0599]: no variant or associated item named `Star` found for enum `ast::RepetitionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1542:72\n     |\n1150 | pub enum RepetitionKind {\n     | ----------------------- variant or associated item `Star` not found for this enum\n...\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                        ^^^^ variant or associated item not found in `RepetitionKind`\n\nerror[E0560]: struct `ast::Repetition` has no field named `hir`\n    --> regex-syntax/src/ast/mod.rs:1542:92\n     |\n1542 |     let ast = Ast::Repetition(Repetition { span, kind: RepetitionKind::Star, greedy: true, hir: Box::new(Ast::Dot(span)) });\n     |                                                                                            ^^^ `ast::Repetition` does not have this field\n     |\n     = note: available fields are: `op`, `ast`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1544:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1544 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1545:57\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n1545 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Ast::Dot(span)) });\n     |                                                         ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n1545 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(1), ast: Box::new(Ast::Dot(span)) });\n     |                                                         ~~~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1547:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1547 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1550:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1550 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1550:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1550 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(4) };",
                "    let flags = Flags::new(); // Assuming a valid method to initialize Flags",
                "    let set_flags = SetFlags { span, flags };",
                "    let ast = Ast::Flags(set_flags);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(4) };",
                  "    let flags = Flags::new();",
                  "    let set_flags = SetFlags { span, flags };",
                  "    let ast = Ast::Flags(set_flags);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(4) };",
                  "    let flags = Flags::new(); // Assuming a valid method to initialize Flags",
                  "    let set_flags = SetFlags { span, flags };",
                  "    let ast = Ast::Flags(set_flags);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: Position(0), end: Position(4) };",
                  "    let flags = Flags::new();",
                  "    let set_flags = SetFlags { span, flags };",
                  "    let ast = Ast::Flags(set_flags);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(4) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1523:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1523 |       let span = Span { start: Position(0), end: Position(4) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:24\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1524 |     let flags = Flags::new(); // Assuming a valid method to initialize Flags\n     |                        ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1528:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1528 |       let span = Span { start: Position(0), end: Position(4) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1528:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1528 |       let span = Span { start: Position(0), end: Position(4) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:24\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1529 |     let flags = Flags::new();\n     |                        ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: *self matches Ast::Empty(_) is true\n",
        "// constraint: *self matches Ast::Literal(_) or Ast::Empty(_) or Ast::Flags(_) or Ast::Assertion(_) or Ast::Dot(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "Ast::Empty(_), Ast::Literal(_), Ast::Flags(_), Ast::Assertion(_), Ast::Dot(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 0 };",
                "    let ast = Ast::Empty(span.clone());",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span.clone());",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span.clone());",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span.clone());",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n1526 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:38\n     |\n1526 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                "    let ast = Ast::Literal(literal);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(ast.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1524 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1527:30\n     |\n1527 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1527:38\n     |\n1527 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `ast::LiteralKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:54\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n...\n1528 |     let literal = Literal { span, kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                      ^^^^^^^ variant or associated item not found in `LiteralKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let flags = SetFlags { span, flags: Flags::new() };",
                "    let ast = Ast::Flags(flags);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = SetFlags { span, flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert!(!ast.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = SetFlags { span, flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = SetFlags { span, flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert!(!ast.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:48\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1524 |     let flags = SetFlags { span, flags: Flags::new() };\n     |                                                ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1527:30\n     |\n1527 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1527:38\n     |\n1527 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:48\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1528 |     let flags = SetFlags { span, flags: Flags::new() };\n     |                                                ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let assertion = Assertion { span, kind: AssertionKind::StartOfString };",
                "    let ast = Ast::Assertion(assertion);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartOfString };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(!ast.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartOfString };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartOfString };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(!ast.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `StartOfString` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1524:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `StartOfString` not found for this enum\n...\n1524 |     let assertion = Assertion { span, kind: AssertionKind::StartOfString };\n     |                                                            ^^^^^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1527:30\n     |\n1527 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1527:38\n     |\n1527 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `StartOfString` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:60\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `StartOfString` not found for this enum\n...\n1528 |     let assertion = Assertion { span, kind: AssertionKind::StartOfString };\n     |                                                            ^^^^^^^^^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let ast = Ast::Dot(span);",
                "    ast.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    ast.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Literal(Literal::Unicode('a'));",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });",
                  "    let result = ast.has_subexprs();",
                  "    let ast = Ast::Dot(span);",
                  "    let result = ast.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:38\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:38\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:37\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1529 |     let ast = Ast::Literal(Literal::Unicode('a'));\n     |                                     ^^^^^^^ associated item not found in `Literal`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:38\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:37\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1529 |     let ast = Ast::Literal(Literal::Unicode('a'));\n     |                                     ^^^^^^^ associated item not found in `Literal`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1531 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:38\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:37\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1529 |     let ast = Ast::Literal(Literal::Unicode('a'));\n     |                                     ^^^^^^^ associated item not found in `Literal`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1531 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1533 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });\n     |                                                                     ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/mod.rs:1519:8\n     |\n1519 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:30\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1523:38\n     |\n1523 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1526:38\n     |\n1526 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no associated item named `Unicode` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1529:37\n     |\n614  | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1529 |     let ast = Ast::Literal(Literal::Unicode('a'));\n     |                                     ^^^^^^^ associated item not found in `Literal`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:57\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1531 |     let ast = Ast::Flags(SetFlags { span, flags: Flags::new() });\n     |                                                         ^^^ function or associated item not found in `ast::Flags`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0599]: no variant or associated item named `Start` found for enum `ast::AssertionKind` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:69\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Start` not found for this enum\n...\n1533 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::Start });\n     |                                                                     ^^^^^ variant or associated item not found in `AssertionKind`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}