{
  "name": "regex_syntax::ast::parse::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre",
  "name_with_impl": "regex_syntax::ast::parse::{impl#7}::visit_pre",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:21:1:21:15"
  },
  "visible": true,
  "loc": "regex-syntax/src/ast/parse.rs:2154:5:2173:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(ref x) is true\n"
      ],
      "input_infer": "1 <= span.start <= span.end <= 2^32 - 1, 1 <= depth <= 2^32 - 1, 0 <= nest_limit <= 2^32 - 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[should_panic]",
            "fn test_visit_pre_concat_depth_limit_exceeded() {",
            "    let start = Position(1);",
            "    let end = Position(2);",
            "    let span = Span { start, end };",
            "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
            "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
            "    let mut nest_limiter = NestLimiter::new(&parser);",
            "    nest_limiter.depth = 1; // Setting depth to exceed the limit",
            "    let _ = nest_limiter.visit_pre(&ast);",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let start = Position(1);",
                "    let end = Position(2);",
                "    let span = Span { start, end };",
                "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ],
                [
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::NestLimitExceeded(1));"
                ],
                [
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };",
                  "    let nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::NestLimitExceeded(1));",
                  "}"
                ],
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: Position(1), end: Position(2) };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };",
                  "    let nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:27\n     |\n5393 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5372:17\n     |\n5372 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:15\n     |\n5373 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5376:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5389 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5391 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5391 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:30\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:48\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5394 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:27\n     |\n5393 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5372:17\n     |\n5372 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:15\n     |\n5373 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5376:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5389 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5391 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5391 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:30\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:48\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5394 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:27\n     |\n5393 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5372:17\n     |\n5372 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:15\n     |\n5373 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5376:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5389 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5391 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5391 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:30\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:48\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5394 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:27\n     |\n5393 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5372:17\n     |\n5372 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:15\n     |\n5373 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5376:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5389 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5391 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5391 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:30\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5392:48\n     |\n5392 |       let span = Span { start: Position(1), end: Position(2) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5394 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let start = Position(1);",
                "    let end = Position(2);",
                "    let span = Span { start, end };",
                "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.depth = 0;",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 1); // Setting depth to exceed the limit"
                ],
                [
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_err()); // Expecting an error due to exceeded depth limit"
                ],
                [
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 0;",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok()); // Expecting no error when under the depth limit"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 0;",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 1); // Setting depth to exceed the limit",
                  "}"
                ],
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 0;",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_err()); // Expecting an error due to exceeded depth limit",
                  "}"
                ],
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 0;",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 0;",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok()); // Expecting no error when under the depth limit",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:27\n     |\n5396 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5372:17\n     |\n5372 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:15\n     |\n5373 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5376:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5389 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5393:17\n     |\n5393 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:15\n     |\n5394 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5397 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:27\n     |\n5396 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5372:17\n     |\n5372 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:15\n     |\n5373 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5376:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5389 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5393:17\n     |\n5393 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:15\n     |\n5394 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5397 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:27\n     |\n5396 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5403:27\n     |\n5403 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5372:17\n     |\n5372 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:15\n     |\n5373 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5376:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5389 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5393:17\n     |\n5393 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:15\n     |\n5394 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5397 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5400:17\n     |\n5400 |       let start = Position(1);\n     |                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5401:15\n     |\n5401 |       let end = Position(2);\n     |                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:70\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };\n     |                                                                      ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5407:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5407 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5407 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let start = Position(1);",
                "    let end = Position(1);",
                "    let span = Span { start, end };",
                "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Parser::default() }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 1;",
                  "    assert!(std::panic::catch_unwind(|| {"
                ],
                [
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 1;",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    }).is_err());",
                  "    let start = Position(1);",
                  "    let end = Position(1);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(1);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 1;",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ],
                [
                  "{",
                  "    let start = Position(1);",
                  "    let end = Position(1);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let start = Position(1);",
                  "    let end = Position(2);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.depth = 1;",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    }).is_err());",
                  "    let start = Position(1);",
                  "    let end = Position(1);",
                  "    let span = Span { start, end };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Parser::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n    --> regex-syntax/src/ast/parse.rs:5399:37\n     |\n5384 | {\n     | - closing delimiter possibly meant for this\n...\n5399 |     assert!(std::panic::catch_unwind(|| {\n     |                                     ^ unclosed delimiter\n5400 | }\n5401 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5401:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5401 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n    --> regex-syntax/src/ast/parse.rs:5367:14\n     |\n5367 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n5400 |     }).is_err());\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> regex-syntax/src/ast/parse.rs:5400:16\n     |\n5400 |     }).is_err());\n     |      -         ^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(ref x) is true\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is true\n"
      ],
      "input_infer": "0 <= depth <= 100, 0 <= nest_limit <= 100, span.start >= 0, span.end >= 0, span.end > span.start\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let start_position = 0;",
                "    let end_position = 5;",
                "    let span = Span { start: start_position, end: end_position };",
                "    let alternation_ast = Ast::Alternation(Alternation {",
                "        span,",
                "        asts: vec![],",
                "    });",
                "",
                "    let parser_i = ParserI {",
                "        parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },",
                "        pattern: \"some pattern\",",
                "    };",
                "",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let depth_before = nest_limiter.depth;",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let depth_after = nest_limiter.depth;",
                  "    assert_eq!(depth_after, depth_before + 1);"
                ],
                [
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let depth_before = nest_limiter.depth;",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let depth_after = nest_limiter.depth;",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ],
                [
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let depth_before = nest_limiter.depth;",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let depth_after = nest_limiter.depth;",
                  "    assert!(depth_after <= parser_i.parser.nest_limit);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },",
                  "        pattern: \"some pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let depth_before = nest_limiter.depth;",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let depth_after = nest_limiter.depth;",
                  "    assert_eq!(depth_after, depth_before + 1);",
                  "}"
                ],
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },",
                  "        pattern: \"some pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let depth_before = nest_limiter.depth;",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let depth_after = nest_limiter.depth;",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },",
                  "        pattern: \"some pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let start_position = 0;",
                  "    let end_position = 5;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let depth_before = nest_limiter.depth;",
                  "    nest_limiter.visit_pre(&alternation_ast).unwrap();",
                  "    let depth_after = nest_limiter.depth;",
                  "    assert!(depth_after <= parser_i.parser.nest_limit);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:44\n     |\n5376 |     let alternation_ast = Ast::Alternation(Alternation {\n     |                                            ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:44\n     |\n5391 |     let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                            ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:17\n     |\n5382 |         parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     nest_limiter.visit_pre(&alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     nest_limiter.visit_post(&alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:51\n     |\n5390 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |     let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };\n     |                                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     nest_limiter.visit_pre(&alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     nest_limiter.visit_post(&alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:44\n     |\n5376 |     let alternation_ast = Ast::Alternation(Alternation {\n     |                                            ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:44\n     |\n5391 |     let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                            ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:17\n     |\n5382 |         parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     nest_limiter.visit_pre(&alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     nest_limiter.visit_post(&alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:51\n     |\n5390 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |     let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };\n     |                                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     nest_limiter.visit_pre(&alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     nest_limiter.visit_post(&alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:44\n     |\n5376 |     let alternation_ast = Ast::Alternation(Alternation {\n     |                                            ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:44\n     |\n5391 |     let alternation_ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                            ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:17\n     |\n5382 |         parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     nest_limiter.visit_pre(&alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     nest_limiter.visit_post(&alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:51\n     |\n5390 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |     let parser_i = ParserI { parser: Parser { nest_limit: 100, /* other fields initialized as needed */ }, pattern: \"some pattern\" };\n     |                                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     nest_limiter.visit_pre(&alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     nest_limiter.visit_post(&alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let start_position = 0;",
                "    let end_position = 10;",
                "    let span = Span { start: start_position, end: end_position };",
                "    let nested_alternation_ast = Ast::Alternation(Alternation {",
                "        span,",
                "        asts: vec![",
                "            Ast::Alternation(Alternation {",
                "                span,",
                "                asts: vec![],",
                "            }),",
                "            Ast::Literal(Literal {/* initialization */})",
                "        ],",
                "    });",
                "",
                "    let parser_i = ParserI {",
                "        parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },",
                "        pattern: \"nested pattern\",",
                "    };",
                "",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&nested_alternation_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ],
                [
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(parser_i.parser.nest_limit >= nest_limiter.depth);"
                ],
                [
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(nest_limiter.visit_pre(&Ast::Alternation(Alternation { span, asts: vec![] })).is_ok());"
                ],
                [
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(nest_limiter.depth < parser_i.parser.nest_limit);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 10;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let nested_alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![",
                  "            Ast::Alternation(Alternation {",
                  "                span,",
                  "                asts: vec![],",
                  "            }),",
                  "            Ast::Literal(Literal {/* initialization */})",
                  "        ],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },",
                  "        pattern: \"nested pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&nested_alternation_ast).unwrap();",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 10;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let nested_alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![",
                  "            Ast::Alternation(Alternation {",
                  "                span,",
                  "                asts: vec![],",
                  "            }),",
                  "            Ast::Literal(Literal {/* initialization */})",
                  "        ],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },",
                  "        pattern: \"nested pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&nested_alternation_ast).unwrap();",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(parser_i.parser.nest_limit >= nest_limiter.depth);",
                  "}"
                ],
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 10;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let nested_alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![",
                  "            Ast::Alternation(Alternation {",
                  "                span,",
                  "                asts: vec![],",
                  "            }),",
                  "            Ast::Literal(Literal {/* initialization */})",
                  "        ],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },",
                  "        pattern: \"nested pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&nested_alternation_ast).unwrap();",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(nest_limiter.visit_pre(&Ast::Alternation(Alternation { span, asts: vec![] })).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 10;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let nested_alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![",
                  "            Ast::Alternation(Alternation {",
                  "                span,",
                  "                asts: vec![],",
                  "            }),",
                  "            Ast::Literal(Literal {/* initialization */})",
                  "        ],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },",
                  "        pattern: \"nested pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&nested_alternation_ast).unwrap();",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(nest_limiter.depth < parser_i.parser.nest_limit);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:51\n     |\n5376 |     let nested_alternation_ast = Ast::Alternation(Alternation {\n     |                                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |             Ast::Alternation(Alternation {\n     |                              ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |             Ast::Literal(Literal {/* initialization */})\n     |                          ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:17\n     |\n5388 |         parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     nest_limiter.visit_pre(&nested_alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     nest_limiter.visit_post(&nested_alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:51\n     |\n5376 |     let nested_alternation_ast = Ast::Alternation(Alternation {\n     |                                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |             Ast::Alternation(Alternation {\n     |                              ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |             Ast::Literal(Literal {/* initialization */})\n     |                          ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:17\n     |\n5388 |         parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     nest_limiter.visit_pre(&nested_alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     nest_limiter.visit_post(&nested_alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:51\n     |\n5376 |     let nested_alternation_ast = Ast::Alternation(Alternation {\n     |                                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |             Ast::Alternation(Alternation {\n     |                              ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |             Ast::Literal(Literal {/* initialization */})\n     |                          ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:54\n     |\n5395 |     assert!(nest_limiter.visit_pre(&Ast::Alternation(Alternation { span, asts: vec![] })).is_ok());\n     |                                                      ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:17\n     |\n5388 |         parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     nest_limiter.visit_pre(&nested_alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     nest_limiter.visit_post(&nested_alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     assert!(nest_limiter.visit_pre(&Ast::Alternation(Alternation { span, asts: vec![] })).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     assert!(nest_limiter.visit_post(&Ast::Alternation(Alternation { span, asts: vec![] })).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:51\n     |\n5376 |     let nested_alternation_ast = Ast::Alternation(Alternation {\n     |                                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |             Ast::Alternation(Alternation {\n     |                              ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |             Ast::Literal(Literal {/* initialization */})\n     |                          ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:17\n     |\n5388 |         parser: Parser { nest_limit: 5, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     nest_limiter.visit_pre(&nested_alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     nest_limiter.visit_post(&nested_alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let start_position = 0;",
                "    let end_position = 8;",
                "    let span = Span { start: start_position, end: end_position };",
                "    let max_depth_alternation_ast = Ast::Alternation(Alternation {",
                "        span,",
                "        asts: vec![",
                "            Ast::Group(Group {",
                "                span,",
                "                kind: GroupKind::Normal,",
                "                ast: Box::new(Ast::Alternation(Alternation {",
                "                    span,",
                "                    asts: vec![],",
                "                })),",
                "            }),",
                "        ],",
                "    });",
                "",
                "    let parser_i = ParserI {",
                "        parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },",
                "        pattern: \"max depth pattern\",",
                "    };",
                "",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&max_depth_alternation_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let start_position = 0;",
                  "    let end_position = 8;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100 }, pattern: \"max depth pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&max_depth_alternation_ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let start_position = 0;",
                  "    let end_position = 8;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100 }, pattern: \"max depth pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&max_depth_alternation_ast);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 8;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let max_depth_alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![",
                  "            Ast::Group(Group {",
                  "                span,",
                  "                kind: GroupKind::Normal,",
                  "                ast: Box::new(Ast::Alternation(Alternation {",
                  "                    span,",
                  "                    asts: vec![],",
                  "                })),",
                  "            }),",
                  "        ],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },",
                  "        pattern: \"max depth pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&max_depth_alternation_ast).unwrap();",
                  "    let start_position = 0;",
                  "    let end_position = 8;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100 }, pattern: \"max depth pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&max_depth_alternation_ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let start_position = 0;",
                  "    let end_position = 8;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let max_depth_alternation_ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![",
                  "            Ast::Group(Group {",
                  "                span,",
                  "                kind: GroupKind::Normal,",
                  "                ast: Box::new(Ast::Alternation(Alternation {",
                  "                    span,",
                  "                    asts: vec![],",
                  "                })),",
                  "            }),",
                  "        ],",
                  "    });",
                  "",
                  "    let parser_i = ParserI {",
                  "        parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },",
                  "        pattern: \"max depth pattern\",",
                  "    };",
                  "",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&max_depth_alternation_ast).unwrap();",
                  "    let start_position = 0;",
                  "    let end_position = 8;",
                  "    let span = Span { start: start_position, end: end_position };",
                  "    let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })] });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 100 }, pattern: \"max depth pattern\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&max_depth_alternation_ast);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:54\n     |\n5376 |     let max_depth_alternation_ast = Ast::Alternation(Alternation {\n     |                                                      ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |             Ast::Group(Group {\n     |                        ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5381:23\n     |\n5381 |                 kind: GroupKind::Normal,\n     |                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |                 ast: Box::new(Ast::Alternation(Alternation {\n     |                                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5400:54\n     |\n5400 |     let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast...\n     |                                                      ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5400:96\n     |\n5400 |     let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast...\n     |                                                                                                ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5400:116\n     |\n5400 | ...n, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })...\n     |                                                 ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5400:166\n     |\n5400 | ...roupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })] });\n     |                                                     ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5391:17\n     |\n5391 |         parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     nest_limiter.visit_pre(&max_depth_alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     nest_limiter.visit_post(&max_depth_alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:30\n     |\n5399 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:51\n     |\n5399 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5401:38\n     |\n5401 |     let parser_i = ParserI { parser: Parser { nest_limit: 100 }, pattern: \"max depth pattern\" };\n     |                                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5403:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5403 |     let result = nest_limiter.visit_pre(&max_depth_alternation_ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5403 |     let result = nest_limiter.visit_post(&max_depth_alternation_ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:54\n     |\n5376 |     let max_depth_alternation_ast = Ast::Alternation(Alternation {\n     |                                                      ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |             Ast::Group(Group {\n     |                        ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5381:23\n     |\n5381 |                 kind: GroupKind::Normal,\n     |                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |                 ast: Box::new(Ast::Alternation(Alternation {\n     |                                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5400:54\n     |\n5400 |     let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast...\n     |                                                      ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5400:96\n     |\n5400 |     let max_depth_alternation_ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast...\n     |                                                                                                ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5400:116\n     |\n5400 | ...n, asts: vec![Ast::Group(Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })...\n     |                                                 ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5400:166\n     |\n5400 | ...roupKind::Normal, ast: Box::new(Ast::Alternation(Alternation { span, asts: vec![] })) })] });\n     |                                                     ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5391:17\n     |\n5391 |         parser: Parser { nest_limit: 100, /* other fields initialized as needed */ },\n     |                 ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     nest_limiter.visit_pre(&max_depth_alternation_ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     nest_limiter.visit_post(&max_depth_alternation_ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:30\n     |\n5399 |     let span = Span { start: start_position, end: end_position };\n     |                              ^^^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:51\n     |\n5399 |     let span = Span { start: start_position, end: end_position };\n     |                                                   ^^^^^^^^^^^^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5401:38\n     |\n5401 |     let parser_i = ParserI { parser: Parser { nest_limit: 100 }, pattern: \"max depth pattern\" };\n     |                                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5403:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5403 |     let result = nest_limiter.visit_pre(&max_depth_alternation_ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5403 |     let result = nest_limiter.visit_post(&max_depth_alternation_ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// constraint: *ast matches Ast::Group(ref x) is true\n"
      ],
      "input_infer": "0 <= depth <= nest_limit, 0 <= start < end < length_of_pattern, 0 <= capture_index < max_capture_index\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let pattern = \"abc\";",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                "    ",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.depth = 0;",
                "    let ast = Ast::Group(group);",
                "    ",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"abc\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:17\n     |\n5374 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5374:37\n     |\n5374 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:17\n     |\n5384 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5384:37\n     |\n5384 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:65\n     |\n5376 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:17\n     |\n5374 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5374:37\n     |\n5374 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:17\n     |\n5384 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5384:37\n     |\n5384 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:65\n     |\n5376 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:17\n     |\n5374 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5374:37\n     |\n5374 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:17\n     |\n5384 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5384:37\n     |\n5384 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:65\n     |\n5376 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span_outer = Span { start: 0, end: 10 };",
                "    let span_inner = Span { start: 2, end: 8 };",
                "    let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };",
                "    let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };",
                "    ",
                "    let pattern = \"abcde\";",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                "    ",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.depth = 0;",
                "    let ast = Ast::Group(outer_group);",
                "    ",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span_outer = Span { start: 0, end: 10 };",
                  "    let span_inner = Span { start: 2, end: 8 };",
                  "    let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };",
                  "    let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ],
                [
                  "    let span_outer = Span { start: 0, end: 10 };",
                  "    let span_inner = Span { start: 2, end: 8 };",
                  "    let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };",
                  "    let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };",
                  "    assert_eq!(nest_limiter.p.parser.nest_limit, 5);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span_outer = Span { start: 0, end: 10 };",
                  "    let span_inner = Span { start: 2, end: 8 };",
                  "    let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };",
                  "    let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };",
                  "    ",
                  "    let pattern = \"abcde\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(outer_group);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span_outer = Span { start: 0, end: 10 };",
                  "    let span_inner = Span { start: 2, end: 8 };",
                  "    let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };",
                  "    let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span_outer = Span { start: 0, end: 10 };",
                  "    let span_inner = Span { start: 2, end: 8 };",
                  "    let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };",
                  "    let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };",
                  "    ",
                  "    let pattern = \"abcde\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Group(outer_group);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span_outer = Span { start: 0, end: 10 };",
                  "    let span_inner = Span { start: 2, end: 8 };",
                  "    let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };",
                  "    let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };",
                  "    assert_eq!(nest_limiter.p.parser.nest_limit, 5);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:23\n     |\n5375 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5375:55\n     |\n5375 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:101\n     |\n5375 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                                                                     ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:23\n     |\n5376 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5376:55\n     |\n5376 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:23\n     |\n5388 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5388:55\n     |\n5388 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:101\n     |\n5388 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                                                                     ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:23\n     |\n5389 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5389:55\n     |\n5389 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:36\n     |\n5373 |     let span_outer = Span { start: 0, end: 10 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:44\n     |\n5373 |     let span_outer = Span { start: 0, end: 10 };\n     |                                            ^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let span_inner = Span { start: 2, end: 8 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let span_inner = Span { start: 2, end: 8 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5379:64\n     |\n5379 |     let parser_i = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:36\n     |\n5386 |     let span_outer = Span { start: 0, end: 10 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:44\n     |\n5386 |     let span_outer = Span { start: 0, end: 10 };\n     |                                            ^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:36\n     |\n5387 |     let span_inner = Span { start: 2, end: 8 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:44\n     |\n5387 |     let span_inner = Span { start: 2, end: 8 };\n     |                                            ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:23\n     |\n5375 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5375:55\n     |\n5375 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:101\n     |\n5375 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                                                                     ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:23\n     |\n5376 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5376:55\n     |\n5376 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:23\n     |\n5388 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5388:55\n     |\n5388 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:101\n     |\n5388 |     let inner_group = Group { span: span_inner, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::new('x'))) };\n     |                                                                                                     ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:23\n     |\n5389 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                       ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5389:55\n     |\n5389 |     let outer_group = Group { span: span_outer, kind: GroupKind::Normal, ast: Box::new(Ast::Group(inner_group)) };\n     |                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:36\n     |\n5373 |     let span_outer = Span { start: 0, end: 10 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:44\n     |\n5373 |     let span_outer = Span { start: 0, end: 10 };\n     |                                            ^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let span_inner = Span { start: 2, end: 8 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let span_inner = Span { start: 2, end: 8 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5379:64\n     |\n5379 |     let parser_i = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:36\n     |\n5386 |     let span_outer = Span { start: 0, end: 10 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:44\n     |\n5386 |     let span_outer = Span { start: 0, end: 10 };\n     |                                            ^^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:36\n     |\n5387 |     let span_inner = Span { start: 2, end: 8 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:44\n     |\n5387 |     let span_inner = Span { start: 2, end: 8 };\n     |                                            ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let pattern = \"xyz\";",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                "    ",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.depth = 0;",
                "    let ast = Ast::Repetition(repetition);",
                "    ",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    ",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let pattern = \"xyz\";",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.depth = 0;",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:22\n     |\n5384 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5384:45\n     |\n5384 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:65\n     |\n5376 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:22\n     |\n5384 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5384:45\n     |\n5384 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:65\n     |\n5376 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:22\n     |\n5384 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5384:45\n     |\n5384 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:65\n     |\n5376 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     let parser_i = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern };\n     |                                                                 ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n",
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n"
      ],
      "input_infer": "0 <= depth <= 2^32 - 1, 0 <= nest_limit <= 2^32 - 1, pattern length > 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let ast = Ast::Repetition(repetition);",
                "",
                "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a+\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:22\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:45\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:62\n     |\n5383 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let ast = Ast::Repetition(repetition);",
                "",
                "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let result = nest_limiter.check(&ast);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::NestLimitExceeded(0));"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::NestLimitExceeded(0));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.check(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:22\n     |\n5382 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5382:45\n     |\n5382 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:62\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:22\n     |\n5382 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5382:45\n     |\n5382 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:62\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:22\n     |\n5382 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5382:45\n     |\n5382 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:62\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 0, ..Default::default() }, pattern: \"a+\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span1 = Span { start: 0, end: 5 };",
                "    let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };",
                "    let ast1 = Ast::Repetition(repetition1);",
                "",
                "    let span2 = Span { start: 6, end: 11 };",
                "    let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };",
                "    let ast2 = Ast::Repetition(repetition2);",
                "",
                "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast2);",
                "}"
              ],
              "oracles": [
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };",
                  "    let ast1 = Ast::Repetition(repetition1);",
                  "    let span2 = Span { start: 6, end: 11 };",
                  "    let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };",
                  "    let ast2 = Ast::Repetition(repetition2);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast2);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };",
                  "    let ast1 = Ast::Repetition(repetition1);",
                  "    let span2 = Span { start: 6, end: 11 };",
                  "    let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };",
                  "    let ast2 = Ast::Repetition(repetition2);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast2);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };",
                  "    let ast1 = Ast::Repetition(repetition1);",
                  "",
                  "    let span2 = Span { start: 6, end: 11 };",
                  "    let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };",
                  "    let ast2 = Ast::Repetition(repetition2);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast2);",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };",
                  "    let ast1 = Ast::Repetition(repetition1);",
                  "    let span2 = Span { start: 6, end: 11 };",
                  "    let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };",
                  "    let ast2 = Ast::Repetition(repetition2);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast2);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };",
                  "    let ast1 = Ast::Repetition(repetition1);",
                  "",
                  "    let span2 = Span { start: 6, end: 11 };",
                  "    let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };",
                  "    let ast2 = Ast::Repetition(repetition2);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast2);",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };",
                  "    let ast1 = Ast::Repetition(repetition1);",
                  "    let span2 = Span { start: 6, end: 11 };",
                  "    let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };",
                  "    let ast2 = Ast::Repetition(repetition2);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast2);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:23\n     |\n5374 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:61\n     |\n5374 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:23\n     |\n5378 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5378:61\n     |\n5378 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:23\n     |\n5385 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5385:61\n     |\n5385 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:23\n     |\n5388 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5388:61\n     |\n5388 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:31\n     |\n5373 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:39\n     |\n5373 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5377:31\n     |\n5377 |     let span2 = Span { start: 6, end: 11 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5377:39\n     |\n5377 |     let span2 = Span { start: 6, end: 11 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5381:62\n     |\n5381 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5383 |     let _ = nest_limiter.visit_pre(&ast2);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5383 |     let _ = nest_limiter.visit_post(&ast2);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n5384 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:39\n     |\n5384 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n5387 |     let span2 = Span { start: 6, end: 11 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:39\n     |\n5387 |     let span2 = Span { start: 6, end: 11 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5390:62\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast2);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast2);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:23\n     |\n5374 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:61\n     |\n5374 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:23\n     |\n5378 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5378:61\n     |\n5378 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:23\n     |\n5385 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5385:61\n     |\n5385 |     let repetition1 = Repetition { span: span1.clone(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(span1.clone())) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:23\n     |\n5388 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5388:61\n     |\n5388 |     let repetition2 = Repetition { span: span2.clone(), op: RepetitionOp::Star, greedy: false, ast: Box::new(ast1) };\n     |                                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:31\n     |\n5373 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:39\n     |\n5373 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5377:31\n     |\n5377 |     let span2 = Span { start: 6, end: 11 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5377:39\n     |\n5377 |     let span2 = Span { start: 6, end: 11 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5381:62\n     |\n5381 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5383 |     let _ = nest_limiter.visit_pre(&ast2);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5383 |     let _ = nest_limiter.visit_post(&ast2);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n5384 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:39\n     |\n5384 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n5387 |     let span2 = Span { start: 6, end: 11 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:39\n     |\n5387 |     let span2 = Span { start: 6, end: 11 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5390:62\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: \"a+?\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast2);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast2);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let ast = Ast::Repetition(repetition);",
                "",
                "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:22\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:45\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:62\n     |\n5383 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:22\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:45\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:62\n     |\n5383 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 0 };",
                "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let ast = Ast::Repetition(repetition);",
                "",
                "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(nest_limiter.depth == 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(nest_limiter.depth == 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:22\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:45\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:62\n     |\n5383 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:22\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:45\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:62\n     |\n5383 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5374:22\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5374:45\n     |\n5374 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:22\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                      ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:45\n     |\n5381 |     let repetition = Repetition { span, op: RepetitionOp::Plus, greedy: false, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:62\n     |\n5383 |     let parser = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: \"\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Perl(_)) or Ast::Class(ast::Class::Unicode(_)) or Ast::Class(ast::Class::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches Ast::Literal(_) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref x)) is true\n"
      ],
      "input_infer": "0 <= depth <= 2, 0 <= nest_limit <= 2, pattern length >= 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let span = Span { start: 0, end: 2 };",
                "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                "",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.p.nest_limit == 2);"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(nest_limiter.depth == 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.p.nest_limit == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(nest_limiter.depth == 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0609]: no field `nest_limit` on type `&parse::ParserI<'_, parse::Parser>`\n    --> regex-syntax/src/ast/parse.rs:5382:28\n     |\n5382 |     assert!(nest_limiter.p.nest_limit == 2);\n     |                            ^^^^^^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n5382 |     assert!(nest_limiter.p.parser.nest_limit == 2);\n     |                            +++++++\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5383 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5383 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5383:112\n     |\n5383 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                                ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5383:112\n     |\n5383 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                                ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(span.clone()));\n     |                          ---------------- ^^^^^^^^^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let span = Span { start: 0, end: 2 };",
                "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                "",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    nest_limiter.visit_pre(&ast_literal).unwrap();",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    nest_limiter.visit_pre(&ast_literal).unwrap();",
                  "    let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    nest_limiter.visit_pre(&ast_literal).unwrap();",
                  "    let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    nest_limiter.visit_pre(&ast_bracketed).unwrap();",
                  "    assert!(nest_limiter.depth == 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    nest_limiter.visit_pre(&ast_literal).unwrap();",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    nest_limiter.visit_pre(&ast_literal).unwrap();",
                  "    let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span.clone()));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });",
                  "    nest_limiter.visit_pre(&ast_literal).unwrap();",
                  "    let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    nest_limiter.visit_pre(&ast_bracketed).unwrap();",
                  "    assert!(nest_limiter.depth == 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:36\n     |\n5386 |     let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });\n     |                                    ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:36\n     |\n5386 |     let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });\n     |                                    ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     nest_limiter.visit_pre(&ast_literal).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     nest_limiter.visit_post(&ast_literal).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:36\n     |\n5386 |     let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });\n     |                                    ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:58\n     |\n5388 |     let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                          ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5388:117\n     |\n5388 |     let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     nest_limiter.visit_pre(&ast_literal).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     nest_limiter.visit_post(&ast_literal).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:36\n     |\n5386 |     let ast_literal = Ast::Literal(Literal { value: 'a', span: span.clone() });\n     |                                    ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:58\n     |\n5388 |     let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                          ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5388:117\n     |\n5388 |     let ast_bracketed = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:46\n     |\n5382 |     let ast = Ast::Class(ast::Class::Unicode(span.clone()));\n     |                          ------------------- ^^^^^^^^^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     nest_limiter.visit_pre(&ast_literal).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     nest_limiter.visit_post(&ast_literal).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5389 |     nest_limiter.visit_pre(&ast_bracketed).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5389 |     nest_limiter.visit_post(&ast_bracketed).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let span = Span { start: 0, end: 2 };",
                "    let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };",
                "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                "",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:86\n     |\n5375 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                                                                                      ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:27\n     |\n5383 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5383:86\n     |\n5383 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                                                                                      ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5380 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5380 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5385:64\n     |\n5385 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:27\n     |\n5375 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:86\n     |\n5375 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                                                                                      ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:27\n     |\n5383 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5383:86\n     |\n5383 |     let bracketed_class = ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal };\n     |                                                                                      ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5380 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5380 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5385:64\n     |\n5385 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let span = Span { start: 0, end: 3 };",
                "    let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });",
                "",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"abc\";",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"abc\";",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |     let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:28\n     |\n5382 |     let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |     let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:28\n     |\n5382 |     let ast = Ast::Literal(Literal { span: span.clone(), value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 2, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5385 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5385 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let span = Span { start: 0, end: 2 };",
                "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                "",
                "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(span.start, 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(span.end, 2);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(matches!(ast, Ast::Class(ast::Class::Bracketed(_))));"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(matches!(ast, Ast::Class(ast::Class::Normal(_))));"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    assert_eq!(parser_i.pattern, \".*\");"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    assert_eq!(parser_i.parser.nest_limit, 1);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.increment_depth(&span).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(span.start, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(span.end, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(matches!(ast, Ast::Class(ast::Class::Bracketed(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(matches!(ast, Ast::Class(ast::Class::Normal(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    assert_eq!(parser_i.pattern, \".*\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    assert_eq!(parser_i.parser.nest_limit, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));",
                  "    let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_i);",
                  "    nest_limiter.increment_depth(&span).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:28\n     |\n5383 |     assert_eq!(span.start, 0);\n     |                            ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     assert_eq!(span.end, 2);\n     |                          ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ast::Class` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:50\n     |\n5383 |     assert!(matches!(ast, Ast::Class(ast::Class::Normal(_))));\n     |                                                  ^^^^^^ variant or associated item not found in `ast::Class`\n     |\n    ::: regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | pub enum Class {\n     | -------------- variant or associated item `Normal` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:48\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:107\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:48\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5382:107\n     |\n5382 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet::Normal }));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:38\n     |\n5381 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5383:64\n     |\n5383 |     let parser_i = ParserI { parser: Parser { nest_limit: 1, ..Default::default() }, pattern: pattern };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Perl(_)) or Ast::Class(ast::Class::Unicode(_)) or Ast::Class(ast::Class::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches Ast::Empty(_) is true\n",
        "// constraint: *ast matches Ast::Dot(_) or Ast::Class(ast::Class::Perl(_)) or Ast::Class(ast::Class::Unicode(_)) or Ast::Flags(_) or Ast::Empty(_) or Ast::Literal(_) or Ast::Assertion(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "1 <= depth <= 10, 0 <= nest_limit <= 10, span.start <= span.end <= 1000, pattern.len() <= 1000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 0 };",
                "    let ast = Ast::Empty(span);",
                "    let pattern = \"a*\";",
                "    let parser_instance = ParserI { ",
                "        parser: Parser { ",
                "            pos: Cell::new(0), ",
                "            capture_index: Cell::new(0), ",
                "            nest_limit: 5, ",
                "            octal: false, ",
                "            initial_ignore_whitespace: false, ",
                "            ignore_whitespace: Cell::new(false), ",
                "            comments: RefCell::new(vec![]), ",
                "            stack_group: RefCell::new(vec![]), ",
                "            stack_class: RefCell::new(vec![]), ",
                "            capture_names: RefCell::new(vec![]), ",
                "            scratch: RefCell::new(String::new()) ",
                "        }, ",
                "        pattern ",
                "    };",
                "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 6, end: 6 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 5, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"a*\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 5,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::default());",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 6, end: 6 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5415:107\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:48\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                          --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassBracketed`, found `Box<ClassBracketed>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Box<ClassBracketed>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\nhelp: consider unboxing the value\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(*Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                +\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5416:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5416 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5416 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5417:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5417 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5417 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5415:107\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:48\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                          --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassBracketed`, found `Box<ClassBracketed>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Box<ClassBracketed>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\nhelp: consider unboxing the value\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(*Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                +\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5416:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5416 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5416 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:30\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:38\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:43\n     |\n5418 |     let ast = Ast::Class(ast::Class::Perl(Box::new(0)));\n     |                          ---------------- ^^^^^^^^^^^ expected `ClassPerl`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5419 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5419 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5420:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5420 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5420 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5415:107\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:48\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                          --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassBracketed`, found `Box<ClassBracketed>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Box<ClassBracketed>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\nhelp: consider unboxing the value\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(*Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                +\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5416:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5416 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5416 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:30\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:38\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:43\n     |\n5418 |     let ast = Ast::Class(ast::Class::Perl(Box::new(0)));\n     |                          ---------------- ^^^^^^^^^^^ expected `ClassPerl`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5419 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5419 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:30\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:38\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5421:46\n     |\n5421 |     let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));\n     |                          ------------------- ^^^^^^^^^^^ expected `ClassUnicode`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5422:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5422 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5422 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5423:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5423 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5423 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5415:107\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5424:26\n     |\n5424 |     let ast = Ast::Flags(SetFlags::default());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:48\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                          --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassBracketed`, found `Box<ClassBracketed>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Box<ClassBracketed>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\nhelp: consider unboxing the value\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(*Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                +\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5416:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5416 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5416 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:30\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:38\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:43\n     |\n5418 |     let ast = Ast::Class(ast::Class::Perl(Box::new(0)));\n     |                          ---------------- ^^^^^^^^^^^ expected `ClassPerl`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5419 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5419 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:30\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:38\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5421:46\n     |\n5421 |     let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));\n     |                          ------------------- ^^^^^^^^^^^ expected `ClassUnicode`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5422:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5422 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5422 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:30\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:38\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5425:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5425 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5425 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5426:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5426 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5426 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5415:107\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5424:26\n     |\n5424 |     let ast = Ast::Flags(SetFlags::default());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5427:30\n     |\n5427 |     let ast = Ast::Assertion(Assertion::default());\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:48\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                          --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassBracketed`, found `Box<ClassBracketed>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Box<ClassBracketed>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\nhelp: consider unboxing the value\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(*Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                +\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5416:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5416 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5416 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:30\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:38\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:43\n     |\n5418 |     let ast = Ast::Class(ast::Class::Perl(Box::new(0)));\n     |                          ---------------- ^^^^^^^^^^^ expected `ClassPerl`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5419 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5419 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:30\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:38\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5421:46\n     |\n5421 |     let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));\n     |                          ------------------- ^^^^^^^^^^^ expected `ClassUnicode`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5422:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5422 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5422 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:30\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:38\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5425:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5425 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5425 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5426:30\n     |\n5426 |     let span = Span { start: 4, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5426:38\n     |\n5426 |     let span = Span { start: 4, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5428:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5428 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5428 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5429 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5429 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5415:107\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5424:26\n     |\n5424 |     let ast = Ast::Flags(SetFlags::default());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5427:30\n     |\n5427 |     let ast = Ast::Assertion(Assertion::default());\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:48\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                          --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassBracketed`, found `Box<ClassBracketed>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Box<ClassBracketed>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\nhelp: consider unboxing the value\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(*Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                +\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5416:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5416 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5416 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:30\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:38\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:43\n     |\n5418 |     let ast = Ast::Class(ast::Class::Perl(Box::new(0)));\n     |                          ---------------- ^^^^^^^^^^^ expected `ClassPerl`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5419 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5419 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:30\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:38\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5421:46\n     |\n5421 |     let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));\n     |                          ------------------- ^^^^^^^^^^^ expected `ClassUnicode`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5422:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5422 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5422 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:30\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:38\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5425:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5425 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5425 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5426:30\n     |\n5426 |     let span = Span { start: 4, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5426:38\n     |\n5426 |     let span = Span { start: 4, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5428:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5428 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5428 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5429:30\n     |\n5429 |     let span = Span { start: 5, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5429:38\n     |\n5429 |     let span = Span { start: 5, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5431:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5431 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5431 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5432:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5432 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5432 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 33 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5415:107\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                                                                           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5424:26\n     |\n5424 |     let ast = Ast::Flags(SetFlags::default());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5427:30\n     |\n5427 |     let ast = Ast::Assertion(Assertion::default());\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5433:28\n     |\n5433 |     let ast = Ast::Literal(Literal::new('a', span));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:48\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                          --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassBracketed`, found `Box<ClassBracketed>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Box<ClassBracketed>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\nhelp: consider unboxing the value\n     |\n5415 |     let ast = Ast::Class(ast::Class::Bracketed(*Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal })));\n     |                                                +\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5416:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5416 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5416 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:30\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5417:38\n     |\n5417 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:43\n     |\n5418 |     let ast = Ast::Class(ast::Class::Perl(Box::new(0)));\n     |                          ---------------- ^^^^^^^^^^^ expected `ClassPerl`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5419 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5419 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:30\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:38\n     |\n5420 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5421:46\n     |\n5421 |     let ast = Ast::Class(ast::Class::Unicode(Box::new(0)));\n     |                          ------------------- ^^^^^^^^^^^ expected `ClassUnicode`, found `Box<{integer}>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Box<{integer}>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5422:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5422 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5422 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:30\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:38\n     |\n5423 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5425:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5425 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5425 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5426:30\n     |\n5426 |     let span = Span { start: 4, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5426:38\n     |\n5426 |     let span = Span { start: 4, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5428:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5428 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5428 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5429:30\n     |\n5429 |     let span = Span { start: 5, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5429:38\n     |\n5429 |     let span = Span { start: 5, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5431:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5431 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5431 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5432:30\n     |\n5432 |     let span = Span { start: 6, end: 6 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5432:38\n     |\n5432 |     let span = Span { start: 6, end: 6 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5434:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5434 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5434 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5435 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5435 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 1, end: 1 };",
                "    let ast = Ast::Dot(span);",
                "    let pattern = \".*\";",
                "    let parser_instance = ParserI { ",
                "        parser: Parser { ",
                "            pos: Cell::new(0), ",
                "            capture_index: Cell::new(0), ",
                "            nest_limit: 3, ",
                "            octal: false, ",
                "            initial_ignore_whitespace: false, ",
                "            ignore_whitespace: Cell::new(false), ",
                "            comments: RefCell::new(vec![]), ",
                "            stack_group: RefCell::new(vec![]), ",
                "            stack_class: RefCell::new(vec![]), ",
                "            capture_names: RefCell::new(vec![]), ",
                "            scratch: RefCell::new(String::new()) ",
                "        }, ",
                "        pattern ",
                "    };",
                "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Flags(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Flags(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Literal(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Flags(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Literal(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Assertion(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Flags(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Flags(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Literal(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".*\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 3, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Perl(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Class(ast::Class::Unicode(...));",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Empty(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Dot(span);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Flags(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Literal(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let ast = Ast::Assertion(...);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5397:16\n     |\n5397 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..));\n     |                                           ~~\nhelp: or `..=` for an inclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..=));\n     |                                           ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5397 -     let ast = Ast::Class(ast::Class::Perl(...));\n5397 +     let ast = Ast::Class(ast::Class::Perl(..));\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5399:16\n     |\n5399 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..));\n     |                                           ~~\nhelp: or `..=` for an inclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..=));\n     |                                           ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5397 -     let ast = Ast::Class(ast::Class::Perl(...));\n5397 +     let ast = Ast::Class(ast::Class::Perl(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..));\n     |                                              ~~\nhelp: or `..=` for an inclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..=));\n     |                                              ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5399 -     let ast = Ast::Class(ast::Class::Unicode(...));\n5399 +     let ast = Ast::Class(ast::Class::Unicode(..));\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5401:16\n     |\n5401 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..));\n     |                                           ~~\nhelp: or `..=` for an inclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..=));\n     |                                           ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5397 -     let ast = Ast::Class(ast::Class::Perl(...));\n5397 +     let ast = Ast::Class(ast::Class::Perl(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..));\n     |                                              ~~\nhelp: or `..=` for an inclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..=));\n     |                                              ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5399 -     let ast = Ast::Class(ast::Class::Unicode(...));\n5399 +     let ast = Ast::Class(ast::Class::Unicode(..));\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5403:16\n     |\n5403 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..));\n     |                                           ~~\nhelp: or `..=` for an inclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..=));\n     |                                           ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5397 -     let ast = Ast::Class(ast::Class::Perl(...));\n5397 +     let ast = Ast::Class(ast::Class::Perl(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..));\n     |                                              ~~\nhelp: or `..=` for an inclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..=));\n     |                                              ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5399 -     let ast = Ast::Class(ast::Class::Unicode(...));\n5399 +     let ast = Ast::Class(ast::Class::Unicode(..));\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5405:16\n     |\n5405 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5404 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5404 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..));\n     |                                           ~~\nhelp: or `..=` for an inclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..=));\n     |                                           ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5397 -     let ast = Ast::Class(ast::Class::Perl(...));\n5397 +     let ast = Ast::Class(ast::Class::Perl(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..));\n     |                                              ~~\nhelp: or `..=` for an inclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..=));\n     |                                              ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5399 -     let ast = Ast::Class(ast::Class::Unicode(...));\n5399 +     let ast = Ast::Class(ast::Class::Unicode(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5405:26\n     |\n5405 |     let ast = Ast::Flags(...);\n     |                          ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5405 |     let ast = Ast::Flags(..);\n     |                          ~~\nhelp: or `..=` for an inclusive range\n     |\n5405 |     let ast = Ast::Flags(..=);\n     |                          ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5405:26\n     |\n5405 |     let ast = Ast::Flags(...);\n     |                          ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5405 -     let ast = Ast::Flags(...);\n5405 +     let ast = Ast::Flags(..);\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5407:16\n     |\n5407 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5404 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5404 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..));\n     |                                           ~~\nhelp: or `..=` for an inclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..=));\n     |                                           ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5397 -     let ast = Ast::Class(ast::Class::Perl(...));\n5397 +     let ast = Ast::Class(ast::Class::Perl(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..));\n     |                                              ~~\nhelp: or `..=` for an inclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..=));\n     |                                              ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5399 -     let ast = Ast::Class(ast::Class::Unicode(...));\n5399 +     let ast = Ast::Class(ast::Class::Unicode(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5405:26\n     |\n5405 |     let ast = Ast::Flags(...);\n     |                          ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5405 |     let ast = Ast::Flags(..);\n     |                          ~~\nhelp: or `..=` for an inclusive range\n     |\n5405 |     let ast = Ast::Flags(..=);\n     |                          ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5405:26\n     |\n5405 |     let ast = Ast::Flags(...);\n     |                          ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5405 -     let ast = Ast::Flags(...);\n5405 +     let ast = Ast::Flags(..);\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5407:28\n     |\n5407 |     let ast = Ast::Literal(...);\n     |                            ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5407 |     let ast = Ast::Literal(..);\n     |                            ~~\nhelp: or `..=` for an inclusive range\n     |\n5407 |     let ast = Ast::Literal(..=);\n     |                            ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5407:28\n     |\n5407 |     let ast = Ast::Literal(...);\n     |                            ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5407 -     let ast = Ast::Literal(...);\n5407 +     let ast = Ast::Literal(..);\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5409:16\n     |\n5409 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5404 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5404 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5408 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5408 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |                                                ~~\nhelp: or `..=` for an inclusive range\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(..=));\n     |                                                ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Class(ast::Class::Bracketed(...));\n     |                                                ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5395 -     let ast = Ast::Class(ast::Class::Bracketed(...));\n5395 +     let ast = Ast::Class(ast::Class::Bracketed(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..));\n     |                                           ~~\nhelp: or `..=` for an inclusive range\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(..=));\n     |                                           ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5397:43\n     |\n5397 |     let ast = Ast::Class(ast::Class::Perl(...));\n     |                                           ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5397 -     let ast = Ast::Class(ast::Class::Perl(...));\n5397 +     let ast = Ast::Class(ast::Class::Perl(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..));\n     |                                              ~~\nhelp: or `..=` for an inclusive range\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(..=));\n     |                                              ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(...));\n     |                                              ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5399 -     let ast = Ast::Class(ast::Class::Unicode(...));\n5399 +     let ast = Ast::Class(ast::Class::Unicode(..));\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5405:26\n     |\n5405 |     let ast = Ast::Flags(...);\n     |                          ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5405 |     let ast = Ast::Flags(..);\n     |                          ~~\nhelp: or `..=` for an inclusive range\n     |\n5405 |     let ast = Ast::Flags(..=);\n     |                          ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5405:26\n     |\n5405 |     let ast = Ast::Flags(...);\n     |                          ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5405 -     let ast = Ast::Flags(...);\n5405 +     let ast = Ast::Flags(..);\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5407:28\n     |\n5407 |     let ast = Ast::Literal(...);\n     |                            ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5407 |     let ast = Ast::Literal(..);\n     |                            ~~\nhelp: or `..=` for an inclusive range\n     |\n5407 |     let ast = Ast::Literal(..=);\n     |                            ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5407:28\n     |\n5407 |     let ast = Ast::Literal(...);\n     |                            ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5407 -     let ast = Ast::Literal(...);\n5407 +     let ast = Ast::Literal(..);\n     |\n\nerror: unexpected token: `...`\n    --> regex-syntax/src/ast/parse.rs:5409:30\n     |\n5409 |     let ast = Ast::Assertion(...);\n     |                              ^^^\n     |\nhelp: use `..` for an exclusive range\n     |\n5409 |     let ast = Ast::Assertion(..);\n     |                              ~~\nhelp: or `..=` for an inclusive range\n     |\n5409 |     let ast = Ast::Assertion(..=);\n     |                              ~~~\n\nerror[E0586]: inclusive range with no end\n    --> regex-syntax/src/ast/parse.rs:5409:30\n     |\n5409 |     let ast = Ast::Assertion(...);\n     |                              ^^^\n     |\n     = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n     |\n5409 -     let ast = Ast::Assertion(...);\n5409 +     let ast = Ast::Assertion(..);\n     |\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0423]: expected value, found module `result`\n    --> regex-syntax/src/ast/parse.rs:5411:16\n     |\n5411 |     assert_eq!(result, Ok(()));\n     |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 1, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5404 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5404 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5408 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5408 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5410:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5410 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5410 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0586, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 2, end: 2 };",
                "    let ast = Ast::Class(ast::Class::Perl(span));",
                "    let pattern = \"\\\\d+\";",
                "    let parser_instance = ParserI { ",
                "        parser: Parser { ",
                "            pos: Cell::new(0), ",
                "            capture_index: Cell::new(0), ",
                "            nest_limit: 7, ",
                "            octal: true, ",
                "            initial_ignore_whitespace: false, ",
                "            ignore_whitespace: Cell::new(false), ",
                "            comments: RefCell::new(vec![]), ",
                "            stack_group: RefCell::new(vec![]), ",
                "            stack_class: RefCell::new(vec![]), ",
                "            capture_names: RefCell::new(vec![]), ",
                "            scratch: RefCell::new(String::new()) ",
                "        }, ",
                "        pattern ",
                "    };",
                "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Flags(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Flags(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Literal(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Flags(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Literal(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Flags(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Flags(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Literal(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"\\\\d+\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 7, ",
                  "            octal: true, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Empty(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Flags(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Literal(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 2, end: 2 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:30\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:38\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:30\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:38\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:38\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:48\n     |\n5401 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:30\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:38\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:38\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:48\n     |\n5401 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:30\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:38\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5405 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5405 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:30\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:38\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:38\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:48\n     |\n5401 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:30\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:38\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5405 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5405 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5408 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5408 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:30\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:38\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:38\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:48\n     |\n5401 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:30\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:38\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5405 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5405 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5408 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5408 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5409:30\n     |\n5409 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5409:38\n     |\n5409 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:26\n     |\n5410 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5411 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5411 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:30\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:38\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:38\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:48\n     |\n5401 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:30\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:38\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5405 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5405 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5408 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5408 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5409:30\n     |\n5409 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5409:38\n     |\n5409 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:26\n     |\n5410 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5411 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5411 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5412:30\n     |\n5412 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5412:38\n     |\n5412 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5413:28\n     |\n5413 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5396 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5396 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:30\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5397:38\n     |\n5397 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:38\n     |\n5400 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:48\n     |\n5401 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:30\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5403:38\n     |\n5403 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5405 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5405 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5408 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5408 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5409:30\n     |\n5409 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5409:38\n     |\n5409 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:26\n     |\n5410 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5411 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5411 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5412:30\n     |\n5412 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5412:38\n     |\n5412 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5413:28\n     |\n5413 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:30\n     |\n5415 |     let span = Span { start: 2, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:38\n     |\n5415 |     let span = Span { start: 2, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5416:30\n     |\n5416 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5417:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5417 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5417 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 36 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 3, end: 3 };",
                "    let ast = Ast::Class(ast::Class::Unicode(span));",
                "    let pattern = \"[a-zA-Z]\";",
                "    let parser_instance = ParserI { ",
                "        parser: Parser { ",
                "            pos: Cell::new(0), ",
                "            capture_index: Cell::new(0), ",
                "            nest_limit: 4, ",
                "            octal: false, ",
                "            initial_ignore_whitespace: true, ",
                "            ignore_whitespace: Cell::new(true), ",
                "            comments: RefCell::new(vec![]), ",
                "            stack_group: RefCell::new(vec![]), ",
                "            stack_class: RefCell::new(vec![]), ",
                "            capture_names: RefCell::new(vec![]), ",
                "            scratch: RefCell::new(String::new()) ",
                "        }, ",
                "        pattern ",
                "    };",
                "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Flags(span);",
                  "    let pattern = \"(?i)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Flags(span);",
                  "    let pattern = \"(?i)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Literal(span);",
                  "    let pattern = \"a\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Flags(span);",
                  "    let pattern = \"(?i)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Literal(span);",
                  "    let pattern = \"a\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let pattern = \"(?=a)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 4, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: true, ",
                  "            ignore_whitespace: Cell::new(true), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 4, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: true, ",
                  "            ignore_whitespace: Cell::new(true), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 4, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: true, ",
                  "            ignore_whitespace: Cell::new(true), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 4, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: true, ",
                  "            ignore_whitespace: Cell::new(true), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 4, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: true, ",
                  "            ignore_whitespace: Cell::new(true), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Flags(span);",
                  "    let pattern = \"(?i)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 4, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: true, ",
                  "            ignore_whitespace: Cell::new(true), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Flags(span);",
                  "    let pattern = \"(?i)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Literal(span);",
                  "    let pattern = \"a\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 4, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: true, ",
                  "            ignore_whitespace: Cell::new(true), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 3, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let pattern = \"[a-zA-Z]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let pattern = \"[0-9]\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let pattern = \"\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 5, end: 5 };",
                  "    let ast = Ast::Dot(span);",
                  "    let pattern = \".\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Flags(span);",
                  "    let pattern = \"(?i)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Literal(span);",
                  "    let pattern = \"a\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let pattern = \"(?=a)\";",
                  "    let parser_instance = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(0),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 4,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: true,",
                  "    ignore_whitespace: Cell::new(true),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new())",
                  "    },",
                  "    pattern",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:30\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:38\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5416:48\n     |\n5416 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:20\n     |\n5420 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5435 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5435 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:30\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:38\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5416:48\n     |\n5416 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:20\n     |\n5420 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5435 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5435 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:30\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:38\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5441:20\n     |\n5441 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5456:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5456 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5456 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:30\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:38\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5416:48\n     |\n5416 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:20\n     |\n5420 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5435 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5435 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:30\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:38\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5441:20\n     |\n5441 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5456:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5456 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5456 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:30\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:38\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5462:20\n     |\n5462 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5477:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5477 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5477 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:30\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:38\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5416:48\n     |\n5416 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:20\n     |\n5420 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5435 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5435 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:30\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:38\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5441:20\n     |\n5441 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5456:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5456 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5456 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:30\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:38\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5462:20\n     |\n5462 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5477:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5477 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5477 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5478:30\n     |\n5478 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5478:38\n     |\n5478 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5479:26\n     |\n5479 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5483:20\n     |\n5483 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5498:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5498 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5498 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:30\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:38\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5416:48\n     |\n5416 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:20\n     |\n5420 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5435 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5435 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:30\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:38\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5441:20\n     |\n5441 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5456:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5456 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5456 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:30\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:38\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5462:20\n     |\n5462 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5477:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5477 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5477 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5478:30\n     |\n5478 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5478:38\n     |\n5478 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5479:26\n     |\n5479 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5483:20\n     |\n5483 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5498:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5498 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5498 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5499:30\n     |\n5499 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5499:38\n     |\n5499 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5500:28\n     |\n5500 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5504:20\n     |\n5504 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5519:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5519 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5519 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:28\n     |\n5378 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5393 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5393 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 3, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:20\n     |\n5399 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:30\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:38\n     |\n5415 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5416:48\n     |\n5416 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5420:20\n     |\n5420 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5435 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5435 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:30\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5436:38\n     |\n5436 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5441:20\n     |\n5441 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5456:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5456 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5456 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:30\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5457:38\n     |\n5457 |     let span = Span { start: 5, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5462:20\n     |\n5462 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5477:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5477 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5477 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5478:30\n     |\n5478 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5478:38\n     |\n5478 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5479:26\n     |\n5479 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5483:20\n     |\n5483 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5498:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5498 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5498 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5499:30\n     |\n5499 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5499:38\n     |\n5499 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5500:28\n     |\n5500 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5504:20\n     |\n5504 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5519:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5519 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5519 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5520:30\n     |\n5520 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5520:38\n     |\n5520 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5521:30\n     |\n5521 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5525:20\n     |\n5525 |     pos: Cell::new(0),\n     |          --------- ^ expected `Position`, found integer\n     |          |\n     |          arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5540:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5540 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5540 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 39 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 4, end: 5 };",
                "    let inner_span = Span { start: 4, end: 5 };",
                "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                "    let pattern = \"[abc]\";",
                "    let parser_instance = ParserI { ",
                "        parser: Parser { ",
                "            pos: Cell::new(0), ",
                "            capture_index: Cell::new(0), ",
                "            nest_limit: 6, ",
                "            octal: false, ",
                "            initial_ignore_whitespace: false, ",
                "            ignore_whitespace: Cell::new(false), ",
                "            comments: RefCell::new(vec![]), ",
                "            stack_group: RefCell::new(vec![]), ",
                "            stack_class: RefCell::new(vec![]), ",
                "            capture_names: RefCell::new(vec![]), ",
                "            scratch: RefCell::new(String::new()) ",
                "        }, ",
                "        pattern ",
                "    };",
                "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    assert_eq!(result_empty, Ok(()));"
                ],
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    assert_eq!(result_dot, Ok(()));"
                ],
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));",
                  "    let result_literal = nest_limiter.visit_pre(&ast_literal);",
                  "    assert_eq!(result_literal, Ok(()));"
                ],
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));",
                  "    let result_literal = nest_limiter.visit_pre(&ast_literal);",
                  "    let ast_flags = Ast::Flags(SetFlags::new(vec![]));",
                  "    let result_flags = nest_limiter.visit_pre(&ast_flags);",
                  "    assert_eq!(result_flags, Ok(()));"
                ],
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));",
                  "    let result_literal = nest_limiter.visit_pre(&ast_literal);",
                  "    let ast_flags = Ast::Flags(SetFlags::new(vec![]));",
                  "    let result_flags = nest_limiter.visit_pre(&ast_flags);",
                  "    let ast_assertion = Ast::Assertion(Assertion::new());",
                  "    let result_assertion = nest_limiter.visit_pre(&ast_assertion);",
                  "    assert_eq!(result_assertion, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let inner_span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let pattern = \"[abc]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 6, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let inner_span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let pattern = \"[abc]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 6, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    assert_eq!(result_empty, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let inner_span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let pattern = \"[abc]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 6, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    assert_eq!(result_dot, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let inner_span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let pattern = \"[abc]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 6, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));",
                  "    let result_literal = nest_limiter.visit_pre(&ast_literal);",
                  "    assert_eq!(result_literal, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let inner_span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let pattern = \"[abc]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 6, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));",
                  "    let result_literal = nest_limiter.visit_pre(&ast_literal);",
                  "    let ast_flags = Ast::Flags(SetFlags::new(vec![]));",
                  "    let result_flags = nest_limiter.visit_pre(&ast_flags);",
                  "    assert_eq!(result_flags, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let inner_span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let pattern = \"[abc]\";",
                  "    let parser_instance = ParserI { ",
                  "        parser: Parser { ",
                  "            pos: Cell::new(0), ",
                  "            capture_index: Cell::new(0), ",
                  "            nest_limit: 6, ",
                  "            octal: false, ",
                  "            initial_ignore_whitespace: false, ",
                  "            ignore_whitespace: Cell::new(false), ",
                  "            comments: RefCell::new(vec![]), ",
                  "            stack_group: RefCell::new(vec![]), ",
                  "            stack_class: RefCell::new(vec![]), ",
                  "            capture_names: RefCell::new(vec![]), ",
                  "            scratch: RefCell::new(String::new()) ",
                  "        }, ",
                  "        pattern ",
                  "    };",
                  "    let mut nest_limiter = NestLimiter::new(&parser_instance);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let ast_empty = Ast::Empty(Span { start: 0, end: 0 });",
                  "    let result_empty = nest_limiter.visit_pre(&ast_empty);",
                  "    let ast_dot = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let result_dot = nest_limiter.visit_pre(&ast_dot);",
                  "    let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));",
                  "    let result_literal = nest_limiter.visit_pre(&ast_literal);",
                  "    let ast_flags = Ast::Flags(SetFlags::new(vec![]));",
                  "    let result_flags = nest_limiter.visit_pre(&ast_flags);",
                  "    let ast_assertion = Ast::Assertion(Assertion::new());",
                  "    let result_assertion = nest_limiter.visit_pre(&ast_assertion);",
                  "    assert_eq!(result_assertion, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:78\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:78\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5375:50\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5375:56\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5375:72\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:28\n     |\n5379 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:38\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5396:50\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5396:56\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5396:72\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0559, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:78\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:78\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5375:50\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5375:56\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5375:72\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:28\n     |\n5379 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:38\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5396:50\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5396:56\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5396:72\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:54\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:37\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result_empty = nest_limiter.visit_pre(&ast_empty);\n     |                                     ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result_empty = nest_limiter.visit_post(&ast_empty);\n     |                                     ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0559, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:78\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:78\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5375:50\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5375:56\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5375:72\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:28\n     |\n5379 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:38\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5396:50\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5396:56\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5396:72\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:54\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:37\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result_empty = nest_limiter.visit_pre(&ast_empty);\n     |                                     ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result_empty = nest_limiter.visit_post(&ast_empty);\n     |                                     ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:42\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:50\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5401:35\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5401 |     let result_dot = nest_limiter.visit_pre(&ast_dot);\n     |                                   ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5401 |     let result_dot = nest_limiter.visit_post(&ast_dot);\n     |                                   ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0559, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:78\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:78\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5402:36\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                    ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5375:50\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5375:56\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5375:72\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:28\n     |\n5379 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:38\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5396:50\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5396:56\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5396:72\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:54\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:37\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result_empty = nest_limiter.visit_pre(&ast_empty);\n     |                                     ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result_empty = nest_limiter.visit_post(&ast_empty);\n     |                                     ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:42\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:50\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5401:35\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5401 |     let result_dot = nest_limiter.visit_pre(&ast_dot);\n     |                                   ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5401 |     let result_dot = nest_limiter.visit_post(&ast_dot);\n     |                                   ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:68\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:76\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5403:39\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5403 |     let result_literal = nest_limiter.visit_pre(&ast_literal);\n     |                                       ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5403 |     let result_literal = nest_limiter.visit_post(&ast_literal);\n     |                                       ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0559, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:78\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:78\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5402:36\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                    ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5404:32\n     |\n5404 |     let ast_flags = Ast::Flags(SetFlags::new(vec![]));\n     |                                ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5375:50\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5375:56\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5375:72\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:28\n     |\n5379 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:38\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5396:50\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5396:56\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5396:72\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:54\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:37\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result_empty = nest_limiter.visit_pre(&ast_empty);\n     |                                     ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result_empty = nest_limiter.visit_post(&ast_empty);\n     |                                     ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:42\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:50\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5401:35\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5401 |     let result_dot = nest_limiter.visit_pre(&ast_dot);\n     |                                   ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5401 |     let result_dot = nest_limiter.visit_post(&ast_dot);\n     |                                   ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:68\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:76\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5403:39\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5403 |     let result_literal = nest_limiter.visit_pre(&ast_literal);\n     |                                       ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5403 |     let result_literal = nest_limiter.visit_post(&ast_literal);\n     |                                       ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:37\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5405 |     let result_flags = nest_limiter.visit_pre(&ast_flags);\n     |                                     ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5405 |     let result_flags = nest_limiter.visit_post(&ast_flags);\n     |                                     ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0559, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5375:78\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:78\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5402:36\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                    ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5404:32\n     |\n5404 |     let ast_flags = Ast::Flags(SetFlags::new(vec![]));\n     |                                ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5406:40\n     |\n5406 |     let ast_assertion = Ast::Assertion(Assertion::new());\n     |                                        ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:36\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:44\n     |\n5374 |     let inner_span = Span { start: 4, end: 5 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5375:50\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5375:56\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5375:72\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5375 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:28\n     |\n5379 |             pos: Cell::new(0), \n     |                  --------- ^ expected `Position`, found integer\n     |                  |\n     |                  arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:38\n     |\n5395 |     let span = Span { start: 4, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `span`\n    --> regex-syntax/src/ast/parse.rs:5396:50\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                  ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `negated`\n    --> regex-syntax/src/ast/parse.rs:5396:56\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                        ^^^^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `ast::Class::Bracketed` has no field named `kind`\n    --> regex-syntax/src/ast/parse.rs:5396:72\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed { span, negated: false, kind: ClassSet::Normal(vec![]) });\n     |                                                                        ^^^^ field does not exist\n     |\n    ::: regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     --------- `ast::Class::Bracketed` defined here\n     |\nhelp: `ast::Class::Bracketed` is a tuple variant, use the appropriate syntax\n     |\n5396 |     let ast = Ast::Class(ast::Class::Bracketed(/* ClassBracketed */));\n     |                                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:46\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:54\n     |\n5398 |     let ast_empty = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:37\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5399 |     let result_empty = nest_limiter.visit_pre(&ast_empty);\n     |                                     ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5399 |     let result_empty = nest_limiter.visit_post(&ast_empty);\n     |                                     ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:42\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5400:50\n     |\n5400 |     let ast_dot = Ast::Dot(Span { start: 0, end: 1 });\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5401:35\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5401 |     let result_dot = nest_limiter.visit_pre(&ast_dot);\n     |                                   ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5401 |     let result_dot = nest_limiter.visit_post(&ast_dot);\n     |                                   ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:68\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:76\n     |\n5402 |     let ast_literal = Ast::Literal(Literal::new(\"a\", Span { start: 0, end: 1 }));\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5403:39\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5403 |     let result_literal = nest_limiter.visit_pre(&ast_literal);\n     |                                       ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5403 |     let result_literal = nest_limiter.visit_post(&ast_literal);\n     |                                       ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:37\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5405 |     let result_flags = nest_limiter.visit_pre(&ast_flags);\n     |                                     ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5405 |     let result_flags = nest_limiter.visit_post(&ast_flags);\n     |                                     ~~~~~~~~~~\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5407:41\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5407 |     let result_assertion = nest_limiter.visit_pre(&ast_assertion);\n     |                                         ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5407 |     let result_assertion = nest_limiter.visit_post(&ast_assertion);\n     |                                         ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0559, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Assertion(_) is true\n",
        "// constraint: *ast matches Ast::Dot(_) or Ast::Class(ast::Class::Perl(_)) or Ast::Class(ast::Class::Unicode(_)) or Ast::Flags(_) or Ast::Empty(_) or Ast::Literal(_) or Ast::Assertion(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "u32 depth: 0 to 1; ast: Ast::Assertion(_) or Ast::Empty(_) or Ast::Flags(_) or Ast::Literal(_) or Ast::Dot(_) or Ast::Class(ast::Class::Perl(_)) or Ast::Class(ast::Class::Unicode(_))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 0 };",
                "    let ast = Ast::Empty(span);",
                "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let ast = Ast::Flags(SetFlags::new()); // Assuming SetFlags::new() initializes a valid SetFlags",
                "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new()); // Assuming SetFlags::new() initializes a valid SetFlags",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new()); // Assuming SetFlags::new() initializes a valid SetFlags",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new()); // Assuming SetFlags::new() initializes a valid SetFlags",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5374:26\n     |\n5374 |     let ast = Ast::Flags(SetFlags::new()); // Assuming SetFlags::new() initializes a valid SetFlags\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n5379 |     let ast = Ast::Flags(SetFlags::new());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5374:26\n     |\n5374 |     let ast = Ast::Flags(SetFlags::new()); // Assuming SetFlags::new() initializes a valid SetFlags\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n5379 |     let ast = Ast::Flags(SetFlags::new());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5374:26\n     |\n5374 |     let ast = Ast::Flags(SetFlags::new()); // Assuming SetFlags::new() initializes a valid SetFlags\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5379:26\n     |\n5379 |     let ast = Ast::Flags(SetFlags::new());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = Literal::new('a'); // Assuming Literal::new(char) initializes a valid Literal",
                "    let ast = Ast::Literal(literal);",
                "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal::new('a'); // Assuming Literal::new(char) initializes a valid Literal",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:19\n     |\n5374 |     let literal = Literal::new('a'); // Assuming Literal::new(char) initializes a valid Literal\n     |                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5380:19\n     |\n5380 |     let literal = Literal::new('a');\n     |                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:36\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:36\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let ast = Ast::Dot(span);",
                "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Concat(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Class(ast::Class::Perl(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Concat(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5386 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5386 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5404:36\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5404:36\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5408:36\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5410:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5410 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5410 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 36 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5404:36\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5408:36\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(span);\n     |               --------------- ^^^^ expected `Repetition`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:493:5\n     |\n493  |     Repetition(Repetition),\n     |     ^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5412:36\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 40 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5404:36\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5408:36\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(span);\n     |               --------------- ^^^^ expected `Repetition`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:493:5\n     |\n493  |     Repetition(Repetition),\n     |     ^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5412:36\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:26\n     |\n5415 |     let ast = Ast::Group(span);\n     |               ---------- ^^^^ expected `Group`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:495:5\n     |\n495  |     Group(Group),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5416:36\n     |\n5416 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5418:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5418 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5418 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5404:36\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5408:36\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(span);\n     |               --------------- ^^^^ expected `Repetition`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:493:5\n     |\n493  |     Repetition(Repetition),\n     |     ^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5412:36\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:26\n     |\n5415 |     let ast = Ast::Group(span);\n     |               ---------- ^^^^ expected `Group`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:495:5\n     |\n495  |     Group(Group),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5416:36\n     |\n5416 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:30\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:38\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5419:32\n     |\n5419 |     let ast = Ast::Alternation(span);\n     |               ---------------- ^^^^ expected `Alternation`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5420:36\n     |\n5420 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5422:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5422 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5422 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 48 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(span);\n     |               ---------- ^^^^ expected `SetFlags`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(span);\n     |               ------------ ^^^^ expected `Literal`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:484:5\n     |\n484  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let ast = Ast::Assertion(span);\n     |               -------------- ^^^^ expected `Assertion`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:488:5\n     |\n488  |     Assertion(Assertion),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |     let ast = Ast::Class(ast::Class::Unicode(span));\n     |                          ------------------- ^^^^ expected `ClassUnicode`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |     let ast = Ast::Class(ast::Class::Perl(span));\n     |                          ---------------- ^^^^ expected `ClassPerl`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5404:36\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(span));\n     |                          --------------------- ^^^^ expected `ClassBracketed`, found `Span`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5408:36\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(span);\n     |               --------------- ^^^^ expected `Repetition`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:493:5\n     |\n493  |     Repetition(Repetition),\n     |     ^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5412:36\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5415:26\n     |\n5415 |     let ast = Ast::Group(span);\n     |               ---------- ^^^^ expected `Group`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:495:5\n     |\n495  |     Group(Group),\n     |     ^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5416:36\n     |\n5416 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:30\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:38\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5419:32\n     |\n5419 |     let ast = Ast::Alternation(span);\n     |               ---------------- ^^^^ expected `Alternation`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5420:36\n     |\n5420 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5422:30\n     |\n5422 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5422:38\n     |\n5422 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5423:27\n     |\n5423 |     let ast = Ast::Concat(span);\n     |               ----------- ^^^^ expected `Concat`, found `Span`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5424:36\n     |\n5424 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5426:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5426 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5426 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 52 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 3 };",
                "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass",
                "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let ast = Ast::Assertion(Assertion);\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these tuple variants\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let ast = Ast::Assertion(Assertion);\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these tuple variants\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5386 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5386 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let ast = Ast::Assertion(Assertion);\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these tuple variants\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0425]: cannot find value `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:46\n     |\n5387 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let ast = Ast::Assertion(Assertion);\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these tuple variants\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0425]: cannot find value `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:46\n     |\n5387 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:26\n     |\n5391 |     let ast = Ast::Flags(SetFlags);\n     |                          ^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let ast = Ast::Assertion(Assertion);\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these tuple variants\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0425]: cannot find value `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:46\n     |\n5387 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:26\n     |\n5391 |     let ast = Ast::Flags(SetFlags);\n     |                          ^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let ast = Ast::Assertion(Assertion);\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these tuple variants\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0425]: cannot find value `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:46\n     |\n5387 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:26\n     |\n5391 |     let ast = Ast::Flags(SetFlags);\n     |                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:28\n     |\n5399 |     let ast = Ast::Literal(Literal);\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these tuple variants\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n5368 +    use hir::HirKind::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5374:43\n     |\n5374 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new())); // Assuming PerlClass::new() initializes a valid PerlClass\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5384:36\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:36\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5396:36\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 3 };",
                "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Literal(Literal::new('a'));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let ast = Ast::Assertion(Assertion::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5389:28\n     |\n5389 |     let ast = Ast::Literal(Literal::new('a'));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5390:36\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5389:28\n     |\n5389 |     let ast = Ast::Literal(Literal::new('a'));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5390:36\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5389:28\n     |\n5389 |     let ast = Ast::Literal(Literal::new('a'));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5390:36\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:30\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:38\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5395:36\n     |\n5395 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5389:28\n     |\n5389 |     let ast = Ast::Literal(Literal::new('a'));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5390:36\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:30\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:38\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5395:36\n     |\n5395 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5389:28\n     |\n5389 |     let ast = Ast::Literal(Literal::new('a'));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5399:30\n     |\n5399 |     let ast = Ast::Assertion(Assertion::new());\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5390:36\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:30\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:38\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5395:36\n     |\n5395 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5389:28\n     |\n5389 |     let ast = Ast::Literal(Literal::new('a'));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5399:30\n     |\n5399 |     let ast = Ast::Assertion(Assertion::new());\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5374:46\n     |\n5374 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new())); // Assuming UnicodeClass::new() initializes a valid UnicodeClass\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5375:36\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClass`\n    --> regex-syntax/src/ast/parse.rs:5379:46\n     |\n5379 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass::new()));\n     |                                              ^^^^^^^^^^^^ use of undeclared type `UnicodeClass`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:36\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:30\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:38\n     |\n5383 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:36\n     |\n5385 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5387 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5387 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5390:36\n     |\n5390 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5392 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5392 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:30\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5393:38\n     |\n5393 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5395:36\n     |\n5395 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5397 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5397 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5400:36\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 2 };",
                "    let assertion = Assertion::new(); // Assuming Assertion::new() initializes a valid Assertion",
                "    let ast = Ast::Assertion(assertion);",
                "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let assertion = Assertion::new();",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let assertion = Assertion::new(); // Assuming Assertion::new() initializes a valid Assertion",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let assertion = Assertion::new();",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5374:21\n     |\n5374 |     let assertion = Assertion::new(); // Assuming Assertion::new() initializes a valid Assertion\n     |                     ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5380:21\n     |\n5380 |     let assertion = Assertion::new();\n     |                     ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:36\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast);\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast);\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:36\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 1 }, pattern: \"\" };\n     |                                    ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Dot(_) is true\n",
        "// constraint: *ast matches Ast::Dot(_) or Ast::Class(ast::Class::Perl(_)) or Ast::Class(ast::Class::Unicode(_)) or Ast::Flags(_) or Ast::Empty(_) or Ast::Literal(_) or Ast::Assertion(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= depth <= 4294967295\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let ast = Ast::Dot(span);",
                "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let class = ast::Class::Perl(vec![]);",
                "    let ast = Ast::Class(class);",
                "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion::new();",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion::new();",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion::new();",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Perl(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags::new());",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal::new('a');",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion::new();",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:30\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:38\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:37\n     |\n5386 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:30\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:38\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:37\n     |\n5386 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:38\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5393:63\n     |\n5393 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5397:26\n     |\n5397 |     let ast = Ast::Flags(SetFlags::new());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:30\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:38\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:37\n     |\n5386 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:38\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5393:63\n     |\n5393 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:30\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5398:63\n     |\n5398 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5397:26\n     |\n5397 |     let ast = Ast::Flags(SetFlags::new());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:30\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:38\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:37\n     |\n5386 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:38\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5393:63\n     |\n5393 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:30\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5398:63\n     |\n5398 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:30\n     |\n5401 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:38\n     |\n5401 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:33\n     |\n5402 |     let literal = ast::Literal::new('a');\n     |                                 ^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n5402 |     let literal = ast::Literal::ne('a');\n     |                                 ~~\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5397:26\n     |\n5397 |     let ast = Ast::Flags(SetFlags::new());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:30\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:38\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:37\n     |\n5386 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:38\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5393:63\n     |\n5393 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:30\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5398:63\n     |\n5398 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:30\n     |\n5401 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:38\n     |\n5401 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:33\n     |\n5402 |     let literal = ast::Literal::new('a');\n     |                                 ^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n5402 |     let literal = ast::Literal::ne('a');\n     |                                 ~~\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:30\n     |\n5407 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:38\n     |\n5407 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:37\n     |\n5408 |     let assertion = ast::Assertion::new();\n     |                                     ^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5410:63\n     |\n5410 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5412:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5412 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5412 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5397:26\n     |\n5397 |     let ast = Ast::Flags(SetFlags::new());\n     |                          ^^^^^^^^ use of undeclared type `SetFlags`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let class = ast::Class::Perl(vec![]);\n     |                 ---------------- ^^^^^^ expected `ClassPerl`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassPerl`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:719:5\n     |\n719  |     Perl(ClassPerl),\n     |     ^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:30\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:38\n     |\n5385 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:37\n     |\n5386 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:38\n     |\n5391 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5393:63\n     |\n5393 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5395 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5395 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:30\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5398:63\n     |\n5398 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5400 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5400 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:30\n     |\n5401 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5401:38\n     |\n5401 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:33\n     |\n5402 |     let literal = ast::Literal::new('a');\n     |                                 ^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n5402 |     let literal = ast::Literal::ne('a');\n     |                                 ~~\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:30\n     |\n5407 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:38\n     |\n5407 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5408:37\n     |\n5408 |     let assertion = ast::Assertion::new();\n     |                                     ^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5410:63\n     |\n5410 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5412:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5412 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5412 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5413:30\n     |\n5413 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5413:38\n     |\n5413 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5415:63\n     |\n5415 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5417:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5417 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5417 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 39 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let class = ast::Class::Unicode(vec![]);",
                "    let ast = Ast::Class(class);",
                "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class = ast::Class::Unicode(vec![]);",
                  "    let ast = Ast::Class(class);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:37\n     |\n5374 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:37\n     |\n5380 |     let class = ast::Class::Unicode(vec![]);\n     |                 ------------------- ^^^^^^ expected `ClassUnicode`, found `Vec<_>`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::ClassUnicode`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:717:5\n     |\n717  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let flags = ast::SetFlags { flags: vec![] };",
                "    let ast = Ast::Flags(flags);",
                "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let flags = ast::SetFlags { flags: vec![] };",
                  "    let ast = Ast::Flags(flags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let flags = ast::SetFlags { flags: vec![] };",
                  "    let ast = Ast::Flags(flags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let flags = ast::SetFlags { flags: vec![] };",
                  "    let ast = Ast::Flags(flags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing field `span` in initializer of `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5374:17\n     |\n5374 |     let flags = ast::SetFlags { flags: vec![] };\n     |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0063]: missing field `span` in initializer of `SetFlags`\n    --> regex-syntax/src/ast/parse.rs:5380:17\n     |\n5380 |     let flags = ast::SetFlags { flags: vec![] };\n     |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:40\n     |\n5374 |     let flags = ast::SetFlags { flags: vec![] };\n     |                                        ^^^^^^ expected `Flags`, found `Vec<_>`\n     |\n     = note: expected struct `ast::Flags`\n                found struct `Vec<_>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:40\n     |\n5380 |     let flags = ast::SetFlags { flags: vec![] };\n     |                                        ^^^^^^ expected `Flags`, found `Vec<_>`\n     |\n     = note: expected struct `ast::Flags`\n                found struct `Vec<_>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0063, E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let ast = Ast::Empty(span);",
                "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Empty(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Flags(SetFlags { flags: 0 });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal { value: 'a' });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5382 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5382 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5386 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5386 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5390 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5390 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5394 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5394 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5398 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5398 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClassKind`\n    --> regex-syntax/src/ast/parse.rs:5399:67\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `UnicodeClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:63\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5402 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5402 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `PerlClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5403:43\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                           ^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClassKind`\n    --> regex-syntax/src/ast/parse.rs:5399:67\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `UnicodeClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:63\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClassKind`\n    --> regex-syntax/src/ast/parse.rs:5403:61\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                                             ^^^^^^^^^^^^^ use of undeclared type `PerlClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5406 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5406 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `PerlClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5403:43\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                           ^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5407:93\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClassKind`\n    --> regex-syntax/src/ast/parse.rs:5399:67\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `UnicodeClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:63\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClassKind`\n    --> regex-syntax/src/ast/parse.rs:5403:61\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                                             ^^^^^^^^^^^^^ use of undeclared type `PerlClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:63\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5410:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5410 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5410 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 40 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `PerlClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5403:43\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                           ^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5407:93\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5411:54\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:121\n     |\n5411 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClassKind`\n    --> regex-syntax/src/ast/parse.rs:5399:67\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `UnicodeClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:63\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClassKind`\n    --> regex-syntax/src/ast/parse.rs:5403:61\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                                             ^^^^^^^^^^^^^ use of undeclared type `PerlClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:63\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5412:63\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5414 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5414 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 46 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `PerlClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5403:43\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                           ^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5407:93\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5411:54\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:121\n     |\n5411 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:26\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:46\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:93\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClassKind`\n    --> regex-syntax/src/ast/parse.rs:5399:67\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `UnicodeClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:63\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClassKind`\n    --> regex-syntax/src/ast/parse.rs:5403:61\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                                             ^^^^^^^^^^^^^ use of undeclared type `PerlClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:63\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5412:63\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5416:63\n     |\n5416 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5418:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5418 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5418 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 52 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `PerlClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5403:43\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                           ^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5407:93\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5411:54\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:121\n     |\n5411 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:26\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:46\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:93\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5419:32\n     |\n5419 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })]...\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5419:76\n     |\n5419 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })]...\n     |                                                                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5419:114\n     |\n5419 | ...Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClassKind`\n    --> regex-syntax/src/ast/parse.rs:5399:67\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `UnicodeClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:63\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClassKind`\n    --> regex-syntax/src/ast/parse.rs:5403:61\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                                             ^^^^^^^^^^^^^ use of undeclared type `PerlClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:63\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5412:63\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5416:63\n     |\n5416 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:30\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:38\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5420:63\n     |\n5420 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5422:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5422 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5422 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 58 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:26\n     |\n5383 |     let ast = Ast::Flags(SetFlags { flags: 0 });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:28\n     |\n5387 |     let ast = Ast::Literal(Literal { value: 'a' });\n     |                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:30\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Assertion;\n     |\n5368 +    use ast::Ast::Assertion;\n     |\n5368 +    use ast::parse::Primitive::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/ast/parse.rs:5395:48\n     |\n5395 |     let ast = Ast::Assertion(Assertion { kind: AssertionKind::WordBoundary });\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `UnicodeClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5399:46\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `PerlClass` in this scope\n    --> regex-syntax/src/ast/parse.rs:5403:43\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                           ^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5407:48\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5407:93\n     |\n5407 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:31\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5411:54\n     |\n5411 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: ...\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:121\n     |\n5411 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:26\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:46\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:93\n     |\n5415 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { value: 'a' })) });\n     |                                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5419:32\n     |\n5419 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })]...\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5419:76\n     |\n5419 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })]...\n     |                                                                            ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5419:114\n     |\n5419 | ...Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5423:27\n     |\n5423 |     let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5423:66\n     |\n5423 |     let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });\n     |                                                                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/ast/parse.rs:5423:104\n     |\n5423 |     let ast = Ast::Concat(Concat { span, asts: vec![Ast::Literal(Literal { value: 'a' }), Ast::Literal(Literal { value: 'b' })] });\n     |                                                                                                        ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Literal;\n     |\n5368 +    use ast::ClassSetItem::Literal;\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use ast::parse::Primitive::Literal;\n     |\n       and 2 other candidates\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5375:63\n     |\n5375 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5377 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5377 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:30\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5378:38\n     |\n5378 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5380:63\n     |\n5380 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:30\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:38\n     |\n5382 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:63\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:30\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:38\n     |\n5386 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:30\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:38\n     |\n5390 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:63\n     |\n5392 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5396:63\n     |\n5396 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:30\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `UnicodeClassKind`\n    --> regex-syntax/src/ast/parse.rs:5399:67\n     |\n5399 |     let ast = Ast::Class(ast::Class::Unicode(UnicodeClass { kind: UnicodeClassKind::Any }));\n     |                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `UnicodeClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:63\n     |\n5400 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5402:38\n     |\n5402 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClassKind`\n    --> regex-syntax/src/ast/parse.rs:5403:61\n     |\n5403 |     let ast = Ast::Class(ast::Class::Perl(PerlClass { kind: PerlClassKind::Any }));\n     |                                                             ^^^^^^^^^^^^^ use of undeclared type `PerlClassKind`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5404:63\n     |\n5404 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:30\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:38\n     |\n5406 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:63\n     |\n5408 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:30\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5410:38\n     |\n5410 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5412:63\n     |\n5412 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:30\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5414:38\n     |\n5414 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5416:63\n     |\n5416 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:30\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5418:38\n     |\n5418 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5420:63\n     |\n5420 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5422:30\n     |\n5422 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5422:38\n     |\n5422 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5424:63\n     |\n5424 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \".*\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5426:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5426 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5426 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 64 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = ast::Literal { span: span.clone(), char: 'a' };",
                "    let ast = Ast::Literal(literal);",
                "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"a\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span: span.clone(), char: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"a\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span: span.clone(), char: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"a\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span: span.clone(), char: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"a\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `char`\n    --> regex-syntax/src/ast/parse.rs:5374:54\n     |\n5374 |     let literal = ast::Literal { span: span.clone(), char: 'a' };\n     |                                                      ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`, `c`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"a\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `char`\n    --> regex-syntax/src/ast/parse.rs:5380:54\n     |\n5380 |     let literal = ast::Literal { span: span.clone(), char: 'a' };\n     |                                                      ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`, `c`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"a\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0560, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let assertion = ast::Assertion { span: span.clone(), kind: ast::AssertionKind::Lookahead };",
                "    let ast = Ast::Assertion(assertion);",
                "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"(?=a)\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    let _ = nest_limiter.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span: span.clone(), kind: ast::AssertionKind::Lookahead };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"(?=a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span: span.clone(), kind: ast::AssertionKind::Lookahead };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"(?=a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let _ = nest_limiter.visit_pre(&ast);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span: span.clone(), kind: ast::AssertionKind::Lookahead };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"(?=a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Lookahead` found for enum `AssertionKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:84\n     |\n5374 |     let assertion = ast::Assertion { span: span.clone(), kind: ast::AssertionKind::Lookahead };\n     |                                                                                    ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1110:1\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Lookahead` not found for this enum\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:63\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"(?=a)\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     let _ = nest_limiter.visit_pre(&ast);\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     let _ = nest_limiter.visit_post(&ast);\n     |                          ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Lookahead` found for enum `AssertionKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:84\n     |\n5380 |     let assertion = ast::Assertion { span: span.clone(), kind: ast::AssertionKind::Lookahead };\n     |                                                                                    ^^^^^^^^^ variant or associated item not found in `AssertionKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1110:1\n     |\n1110 | pub enum AssertionKind {\n     | ---------------------- variant or associated item `Lookahead` not found for this enum\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:63\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 10, ..Default::default() }, pattern: \"(?=a)\" };\n     |                                                               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Flags(_) is true\n",
        "// constraint: *ast matches Ast::Dot(_) or Ast::Class(ast::Class::Perl(_)) or Ast::Class(ast::Class::Unicode(_)) or Ast::Flags(_) or Ast::Empty(_) or Ast::Literal(_) or Ast::Assertion(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "position: 0-100, depth: 0-5, nest_limit: 1-10, pattern: any valid string with length 0-100\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let span = Span { start: 0, end: 2 };",
                "    let ast = Ast::Flags(SetFlags);",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Flags(SetFlags);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:26\n     |\n5375 |     let ast = Ast::Flags(SetFlags);\n     |                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:26\n     |\n5381 |     let ast = Ast::Flags(SetFlags);\n     |                          ^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:26\n     |\n5375 |     let ast = Ast::Flags(SetFlags);\n     |                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `SetFlags` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:26\n     |\n5381 |     let ast = Ast::Flags(SetFlags);\n     |                          ^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let span = Span { start: 0, end: 2 };",
                "    let ast = Ast::Dot(span);",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast).is_ok(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \".*\";",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast = Ast::Dot(span);",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast).is_ok(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     assert_eq!(nest_limiter.visit_pre(&ast).is_ok(), true);\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     assert_eq!(nest_limiter.visit_post(&ast).is_ok(), true);\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a\";",
                "    let span = Span { start: 0, end: 1 };",
                "    let ast = Ast::Literal(Literal::new('a', span));",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\";",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let pattern = \"a\";",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert!(nest_limiter.depth == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"a\";",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"a\";",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast = Ast::Literal(Literal::new('a', span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |     let ast = Ast::Literal(Literal::new('a', span));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5381:28\n     |\n5381 |     let ast = Ast::Literal(Literal::new('a', span));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |     let ast = Ast::Literal(Literal::new('a', span));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5381:28\n     |\n5381 |     let ast = Ast::Literal(Literal::new('a', span));\n     |                            ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"(?=a)\";",
                "    let span = Span { start: 0, end: 4 };",
                "    let ast = Ast::Assertion(Assertion::new(span));",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"(?=a)\";",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let ast = Ast::Assertion(Assertion::new(span));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let ast = Ast::Assertion(Assertion::new(span));\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let ast = Ast::Assertion(Assertion::new(span));\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let ast = Ast::Assertion(Assertion::new(span));\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let ast = Ast::Assertion(Assertion::new(span));\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5375:30\n     |\n5375 |     let ast = Ast::Assertion(Assertion::new(span));\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let ast = Ast::Assertion(Assertion::new(span));\n     |                              ^^^^^^^^^ use of undeclared type `Assertion`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::Assertion;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"[a-z]\";",
                "    let span = Span { start: 0, end: 5 };",
                "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);"
                ],
                [
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"[a-z]\";",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.depth == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5375:43\n     |\n5375 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0433]: failed to resolve: use of undeclared type `PerlClass`\n    --> regex-syntax/src/ast/parse.rs:5381:43\n     |\n5381 |     let ast = Ast::Class(ast::Class::Perl(PerlClass::new(span)));\n     |                                           ^^^^^^^^^ use of undeclared type `PerlClass`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"[\\\\p{L}]\";",
                "    let span = Span { start: 0, end: 7 };",
                "    let ast = Ast::Class(ast::Class::Unicode(ast::UnicodeClass::new(span)));",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"[\\\\p{L}]\";",
                  "    let span = Span { start: 0, end: 7 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(ast::UnicodeClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"[\\\\p{L}]\";",
                  "    let span = Span { start: 0, end: 7 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(ast::UnicodeClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let pattern = \"[\\\\p{L}]\";",
                  "    let span = Span { start: 0, end: 7 };",
                  "    let ast = Ast::Class(ast::Class::Unicode(ast::UnicodeClass::new(span)));",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert!(nest_limiter.visit_pre(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: could not find `UnicodeClass` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let ast = Ast::Class(ast::Class::Unicode(ast::UnicodeClass::new(span)));\n     |                                                   ^^^^^^^^^^^^ could not find `UnicodeClass` in `ast`\n\nerror[E0433]: failed to resolve: could not find `UnicodeClass` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5381:51\n     |\n5381 |     let ast = Ast::Class(ast::Class::Unicode(ast::UnicodeClass::new(span)));\n     |                                                   ^^^^^^^^^^^^ could not find `UnicodeClass` in `ast`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:30\n     |\n5374 |     let span = Span { start: 0, end: 7 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:38\n     |\n5374 |     let span = Span { start: 0, end: 7 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 7 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 7 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:26\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     assert!(nest_limiter.visit_pre(&ast).is_ok());\n     |                          ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     assert!(nest_limiter.visit_post(&ast).is_ok());\n     |                          ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span1 = Span { start: 0, end: 1 };",
                "    let span2 = Span { start: 1, end: 2 };",
                "    let ast1 = Ast::Literal(Literal::new('a', span1));",
                "    let ast2 = Ast::Literal(Literal::new('b', span2));",
                "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"ab\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', span1));",
                  "    let ast2 = Ast::Literal(Literal::new('b', span2));",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"ab\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', span1));",
                  "    let ast2 = Ast::Literal(Literal::new('b', span2));",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"ab\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', span1));",
                  "    let ast2 = Ast::Literal(Literal::new('b', span2));",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"ab\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:29\n     |\n5375 |     let ast1 = Ast::Literal(Literal::new('a', span1));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5376:29\n     |\n5376 |     let ast2 = Ast::Literal(Literal::new('b', span2));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:27\n     |\n5377 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5383:29\n     |\n5383 |     let ast1 = Ast::Literal(Literal::new('a', span1));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5384:29\n     |\n5384 |     let ast2 = Ast::Literal(Literal::new('b', span2));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:27\n     |\n5385 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:31\n     |\n5373 |     let span1 = Span { start: 0, end: 1 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:39\n     |\n5373 |     let span1 = Span { start: 0, end: 1 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:31\n     |\n5374 |     let span2 = Span { start: 1, end: 2 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:39\n     |\n5374 |     let span2 = Span { start: 1, end: 2 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5377:56\n     |\n5377 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5377:64\n     |\n5377 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });\n     |                                                                ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5378:62\n     |\n5378 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"ab\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5380 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5380 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:31\n     |\n5381 |     let span1 = Span { start: 0, end: 1 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:39\n     |\n5381 |     let span1 = Span { start: 0, end: 1 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:31\n     |\n5382 |     let span2 = Span { start: 1, end: 2 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:39\n     |\n5382 |     let span2 = Span { start: 1, end: 2 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:56\n     |\n5385 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:64\n     |\n5385 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 2 }, asts: vec![ast1, ast2] });\n     |                                                                ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:62\n     |\n5386 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"ab\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5388 |     assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));\n     |                             ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5388 |     assert_eq!(nest_limiter.visit_post(&ast), Ok(()));\n     |                             ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 2 };",
                "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:26\n     |\n5375 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:26\n     |\n5381 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5381:46\n     |\n5381 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:26\n     |\n5375 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5375:46\n     |\n5375 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:26\n     |\n5381 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5381:46\n     |\n5381 |     let ast = Ast::Group(Group { span, kind: GroupKind::Capture, ast: Box::new(inner_ast) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"(a)\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 2 };",
                "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let inner_ast = Ast::Literal(Literal::new('a', span));",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:31\n     |\n5375 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5375:54\n     |\n5375 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:31\n     |\n5381 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:54\n     |\n5381 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:34\n     |\n5374 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:31\n     |\n5375 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5375:54\n     |\n5375 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5380:34\n     |\n5380 |     let inner_ast = Ast::Literal(Literal::new('a', span));\n     |                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:31\n     |\n5381 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Repetition;\n     |\n5368 +    use ast::Repetition;\n     |\n5368 +    use hir::HirKind::Repetition;\n     |\n5368 +    use hir::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/ast/parse.rs:5381:54\n     |\n5381 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(inner_ast) });\n     |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5376:62\n     |\n5376 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5378 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5378 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:38\n     |\n5379 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:62\n     |\n5382 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a*\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5384 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5384 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 2 };",
                "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                "    let mut nest_limiter = NestLimiter::new(&parser);",
                "    nest_limiter.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    assert_eq!(nest_limiter.depth, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    nest_limiter.visit_pre(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));",
                  "    let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });",
                  "    let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };",
                  "    let mut nest_limiter = NestLimiter::new(&parser);",
                  "    let result = nest_limiter.visit_pre(&ast);",
                  "    assert_eq!(nest_limiter.depth, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:29\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:29\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:32\n     |\n5376 |     let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5381:29\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:32\n     |\n5383 |     let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:61\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:69\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:61\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:69\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:61\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:69\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:61\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:69\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:62\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:29\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:29\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:32\n     |\n5376 |     let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5381:29\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:32\n     |\n5383 |     let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:61\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:69\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:61\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:69\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:61\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:69\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:61\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:69\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:62\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5386 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5386 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5374:29\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5375:29\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:32\n     |\n5376 |     let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5381:29\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:32\n     |\n5383 |     let ast = Ast::Alternation(Alternation { span, asts: vec![ast1, ast2] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5373:38\n     |\n5373 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:61\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:69\n     |\n5374 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:61\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:69\n     |\n5375 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5377:62\n     |\n5377 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5379:18\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5379 |     nest_limiter.visit_pre(&ast).unwrap();\n     |                  ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5379 |     nest_limiter.visit_post(&ast).unwrap();\n     |                  ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:38\n     |\n5380 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:61\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5381:69\n     |\n5381 |     let ast1 = Ast::Literal(Literal::new('a', Span { start: 0, end: 1 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:61\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5382:69\n     |\n5382 |     let ast2 = Ast::Literal(Literal::new('b', Span { start: 1, end: 2 }));\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5384:62\n     |\n5384 |     let parser = ParserI { parser: Parser { nest_limit: 5, ..Default::default() }, pattern: \"a|b\" };\n     |                                                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `visit_pre` found for struct `parse::NestLimiter` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:31\n     |\n2107 | struct NestLimiter<'p, 's: 'p, P: 'p + 's> {\n     | ------------------------------------------ method `visit_pre` not found for this struct\n...\n5386 |     let result = nest_limiter.visit_pre(&ast);\n     |                               ^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/visitor.rs:48:8\n     |\n48   |     fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n     |        --------- the method is available for `parse::NestLimiter<'_, '_, parse::Parser>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `Visitor` which provides `visit_pre` is implemented but not in scope; perhaps you want to import it\n     |\n5368 +    use ast::visitor::Visitor;\n     |\nhelp: there is a method `visit_post` with a similar name\n     |\n5386 |     let result = nest_limiter.visit_post(&ast);\n     |                               ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}