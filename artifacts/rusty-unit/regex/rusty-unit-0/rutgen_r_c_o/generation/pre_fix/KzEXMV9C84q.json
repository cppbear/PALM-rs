{
  "name": "regex_syntax::hir::literal::repeat_zero_or_more_literals",
  "name_with_impl": "regex_syntax::hir::literal::repeat_zero_or_more_literals",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:27:1:27:17"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/literal/mod.rs:784:1:802:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: lits3.is_empty() is true\n"
      ],
      "input_infer": "lits.limit_size: 0, lits.limit_class: 0, lits.lits: [], e: Hir { kind: HirKind::Complete, info: HirInfo {} }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals::empty();",
                "    lits.set_limit_size(0);",
                "    lits.set_limit_class(0);",
                "    ",
                "    let expr = Hir {",
                "        kind: HirKind::Complete,",
                "        info: hir::HirInfo {},",
                "    };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_size(), 0);"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_class(), 0);"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.literals().len(), 0);"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(!lits.any_complete());"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_size(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_class(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.literals().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(!lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:37\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:53\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:37\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:53\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:37\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:53\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:37\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:53\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:37\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:53\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:37\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:53\n     |\n1572 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals::empty();",
                "    lits.set_limit_size(0);",
                "    lits.set_limit_class(0);",
                "    ",
                "    let expr = Hir {",
                "        kind: HirKind::Complete,",
                "        info: hir::HirInfo {},",
                "    };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                "        // This closure does not modify lits3, ensuring it remains empty",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_size(), 0);"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_class(), 0);"
                ],
                [
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.literals().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // This closure does not modify lits3, ensuring it remains empty",
                  "    });",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // This closure does not modify lits3, ensuring it remains empty",
                  "    });",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_size(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // This closure does not modify lits3, ensuring it remains empty",
                  "    });",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_class(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Complete,",
                  "        info: hir::HirInfo {},",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // This closure does not modify lits3, ensuring it remains empty",
                  "    });",
                  "    let mut lits = Literals::empty();",
                  "    lits.set_limit_size(0);",
                  "    lits.set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {});",
                  "    assert!(lits.literals().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:53\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:53\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:53\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::Complete,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: hir::HirInfo {},\n     |               ^^^^^^^^^^^^ missing `bools`\n\nerror[E0599]: no variant or associated item named `Complete` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Complete` not found for this enum\n\nerror[E0063]: missing field `bools` in initializer of `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:53\n     |\n1574 |     let expr = Hir { kind: HirKind::Complete, info: hir::HirInfo {} };\n     |                                                     ^^^^^^^^^^^^ missing `bools`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: lits3.is_empty() is false\n",
        "// constraint: lits2.cross_product(&lits3) is true\n",
        "// constraint: lits.union(lits2) is true\n"
      ],
      "input_infer": "0 < limit_size <= 1000, 0 < lits.len() <= 100, 0 < v.len() <= 256, 0 < cls.size() <= 50\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                "        limit_size: 1000,",
                "        limit_class: 50,",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Literal(b'a'),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                "        l.add(Literal::new(vec![5, 6]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert_eq!(lits.limit_size(), 1000);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert_eq!(lits.literals().len(), 2);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits.union(lits2));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits2.any_complete());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits3.is_empty() == false);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits1.cross_product(&lits3));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits.lits.iter().any(|lit| lit.v == vec![5, 6]));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(!lits.contains_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert_eq!(lits.min_len(), Some(2));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits.all_complete());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert_eq!(lits.limit_size(), 1000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert_eq!(lits.literals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits.union(lits2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits2.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits3.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits1.cross_product(&lits3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits.lits.iter().any(|lit| lit.v == vec![5, 6]));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert_eq!(lits.min_len(), Some(2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'a'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![5, 6]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };",
                  "    assert!(lits.all_complete());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:24\n     |\n1574 |     assert!(lits.union(lits2));\n     |                        ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:13\n     |\n1574 |     assert!(lits2.any_complete());\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:13\n     |\n1574 |     assert!(lits3.is_empty() == false);\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits1` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:13\n     |\n1574 |     assert!(lits1.cross_product(&lits3));\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:34\n     |\n1574 |     assert!(lits1.cross_product(&lits3));\n     |                                  ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'a'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'a')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'a'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'a')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(vec![1, 2])],",
                "        limit_size: 1000,",
                "        limit_class: 50,",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Literal(b'b'),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                "        l.add(Literal::new(vec![3]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.limit_size(), 1000);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.limit_class, 50);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.literals().len(), 1);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.literals()[0].v, vec![1, 2]);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert!(lits.is_empty() == false);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert_eq!(lits.literals().len(), 2);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert_eq!(lits.literals()[1].v, vec![3]);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert!(lits.union(lits.clone()) == true);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert!(lits.cross_product(&lits) == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.limit_size(), 1000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.limit_class, 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.literals().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert_eq!(lits.literals()[0].v, vec![1, 2]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    assert!(lits.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert_eq!(lits.literals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert_eq!(lits.literals()[1].v, vec![3]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert!(lits.union(lits.clone()) == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'b'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3]));",
                  "    });",
                  "    let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2])], limit_size: 1000, limit_class: 50 };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3])); });",
                  "    assert!(lits.cross_product(&lits) == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:58\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'b'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'b')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1572:45\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(b'b'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1572 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'b')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                "        limit_size: 1000,",
                "        limit_class: 50,",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Literal(b'c'),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                "        l.add(Literal::new(vec![3, 4]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert_eq!(lits.lits.len(), 3);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert_eq!(lits.lits[2].v, vec![3, 4]);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.limit_size() == 1000);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.lits[0].is_cut() == false);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.lits[1].is_cut() == false);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.lits[2].is_cut() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'c'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3, 4]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert_eq!(lits.lits.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'c'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3, 4]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert_eq!(lits.lits[2].v, vec![3, 4]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'c'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3, 4]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'c'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3, 4]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.limit_size() == 1000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'c'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3, 4]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.lits[0].is_cut() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'c'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3, 4]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.lits[1].is_cut() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1]), Literal::new(vec![2])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'c'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3, 4]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1]), Literal::new(vec![2])], limit_size: 1000, limit_class: 50 };",
                  "    let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| { l.add(Literal::new(vec![3, 4])); });",
                  "    assert!(lits.lits[2].is_cut() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'c'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'c')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'c')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'c'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'c')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'c')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'c'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'c')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'c')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'c'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'c')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'c')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'c'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'c')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'c')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'c'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'c')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'c')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1573:58\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'c'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'c')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1573:45\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(b'c'), info: HirInfo::default() };\n     |                            ---------------- ^^^^ expected `Literal`, found `u8`\n     |                            |\n     |                            arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1573 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(b'c')), info: HirInfo::default() };\n     |                                             +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                "        limit_size: 1000,",
                "        limit_class: 50,",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Literal(b'd'),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                "        l.add(Literal::new(vec![3; 256]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert_eq!(lits.lits.len(), 3);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.lits[2].v == vec![3; 256]);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.limit_size == 1000);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.limit_class == 50);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.any_complete());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.all_complete());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(!lits.contains_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.min_len().is_some());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.max_len() == 256);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.union_prefixes(&expr));"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.union_suffixes(&expr));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert_eq!(lits.lits.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.lits[2].v == vec![3; 256]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.limit_size == 1000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.limit_class == 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.min_len().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.max_len() == 256);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "        limit_size: 1000,",
                  "        limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(b'd'),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |e, l| {",
                  "        l.add(Literal::new(vec![3; 256]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new(vec![1; 256]), Literal::new(vec![2; 256])],",
                  "    limit_size: 1000,",
                  "    limit_class: 50,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(b'd'),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    lits.cross_product(&lits3);",
                  "    lits.union(lits2);",
                  "    assert!(lits.union_suffixes(&expr));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nerror[E0599]: no method named `max_len` found for struct `literal::Literals` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1583:18\n     |\n45   | pub struct Literals {\n     | ------------------- method `max_len` not found for this struct\n...\n1583 |     assert!(lits.max_len() == 256);\n     |                  ^^^^^^^\n     |\nhelp: there is a method `min_len` with a similar name\n     |\n1583 |     assert!(lits.min_len() == 256);\n     |                  ~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:25\n     |\n1581 |     lits.cross_product(&lits3);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:16\n     |\n1582 |     lits.union(lits2);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1565:32\n     |\n1565 |         kind: HirKind::Literal(b'd'),\n     |               ---------------- ^^^^ expected `Literal`, found `u8`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1565 |         kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                                +++++++++++++++++++    +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:28\n     |\n1578 |     kind: HirKind::Literal(b'd'),\n     |           ---------------- ^^^^ expected `Literal`, found `u8`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: try wrapping the expression in `hir::Literal::Byte`\n     |\n1578 |     kind: HirKind::Literal(hir::Literal::Byte(b'd')),\n     |                            +++++++++++++++++++    +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: lits3.is_empty() is false\n",
        "// constraint: lits2.cross_product(&lits3) is true\n",
        "// constraint: lits.union(lits2) is false\n"
      ],
      "input_infer": "lits.limit_size: 0 to 10, lits2.num_bytes: 11 to 20, lits3.num_bytes: 1 to 5, lits.lits.len(): 1 to 5, lits3.lits.len(): 1 to 3\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(vec![1, 2, 3])],",
                "        limit_size: 10,",
                "        limit_class: 1,",
                "    };",
                "    ",
                "    let expr = Hir {",
                "        kind: HirKind::Literal,",
                "        info: HirInfo::new(),",
                "    };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(5);",
                "        // Ensure lits3 is not empty",
                "        lits3.add(Literal::new(vec![4, 5]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert!(!lits3.is_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert!(lits2.cross_product(&lits3));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert!(!lits.union(lits2));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.limit_size, 10);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.lits.len(), 2);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.lits[1].v, vec![]);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.lits[1].cut, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2, 3])],",
                  "        limit_size: 10,",
                  "        limit_class: 1,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4, 5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert!(!lits3.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2, 3])],",
                  "        limit_size: 10,",
                  "        limit_class: 1,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4, 5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert!(lits2.cross_product(&lits3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2, 3])],",
                  "        limit_size: 10,",
                  "        limit_class: 1,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4, 5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert!(!lits.union(lits2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2, 3])],",
                  "        limit_size: 10,",
                  "        limit_class: 1,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4, 5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.limit_size, 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2, 3])],",
                  "        limit_size: 10,",
                  "        limit_class: 1,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4, 5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.lits.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2, 3])],",
                  "        limit_size: 10,",
                  "        limit_class: 1,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4, 5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.lits[1].v, vec![]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(vec![1, 2, 3])],",
                  "        limit_size: 10,",
                  "        limit_class: 1,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4, 5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size: 10, limit_class: 1 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| { lits3.set_limit_size(5); lits3.add(Literal::new(vec![4, 5])); });",
                  "    assert_eq!(lits.lits[1].cut, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:15\n     |\n1567 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:52\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:14\n     |\n1578 |     assert!(!lits3.is_empty());\n     |              ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1576:28\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:15\n     |\n1567 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:52\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:13\n     |\n1578 |     assert!(lits2.cross_product(&lits3));\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:34\n     |\n1578 |     assert!(lits2.cross_product(&lits3));\n     |                                  ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1576:28\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:15\n     |\n1567 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:52\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:25\n     |\n1578 |     assert!(!lits.union(lits2));\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1576:28\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:15\n     |\n1567 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:52\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1576:28\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:15\n     |\n1567 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:52\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1576:28\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:15\n     |\n1567 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:52\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1576:28\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:15\n     |\n1567 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:52\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1576:28\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1576 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![1, 2]),",
                "            Literal::new(vec![3, 4])",
                "        ],",
                "        limit_size: 15,",
                "        limit_class: 2,",
                "    };",
                "    ",
                "    let expr = Hir {",
                "        kind: HirKind::Literal,",
                "        info: HirInfo::new(),",
                "    };",
                "",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(3);",
                "        // Ensure lits3 is not empty",
                "        lits3.add(Literal::new(vec![5]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.limit_size(), 15);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.literals().len(), 2);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.union_prefixes(&expr));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.union_suffixes(&expr));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(!lits.any_complete());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(!lits.all_complete());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.len(), 2);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.min_len(), Some(2));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.limit_class(), 2);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.limit_size(), 15);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.add(Literal::new(vec![5])));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.contains_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.to_empty().is_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.longest_common_prefix(), &[1, 2]);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.longest_common_suffix(), &[3, 4]);"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.add_char_class(&hir::ClassUnicode::new()));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.add_byte_class(&hir::ClassBytes::new()));"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(3);",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    lits3.set_limit_size(3);",
                  "    assert!(!lits3.is_empty());"
                ],
                [
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(3);",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    lits3.set_limit_size(3);",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    assert!(lits3.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.limit_size(), 15);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.literals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.union_suffixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(!lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(!lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.min_len(), Some(2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.limit_class(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.limit_size(), 15);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.add(Literal::new(vec![5])));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.to_empty().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.longest_common_prefix(), &[1, 2]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert_eq!(lits.longest_common_suffix(), &[3, 4]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.add_char_class(&hir::ClassUnicode::new()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    assert!(lits.add_byte_class(&hir::ClassBytes::new()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(3);",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    lits3.set_limit_size(3);",
                  "    assert!(!lits3.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![3, 4])",
                  "        ],",
                  "        limit_size: 15,",
                  "        limit_class: 2,",
                  "    };",
                  "    ",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // Ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3, 4])], limit_size: 15, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(3);",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    lits3.set_limit_size(3);",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    assert!(lits3.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nerror[E0599]: no method named `len` found for struct `literal::Literals` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1580:21\n     |\n45   | pub struct Literals {\n     | ------------------- method `len` not found for this struct\n...\n1580 |     assert_eq!(lits.len(), 2);\n     |                     ^^^ method not found in `Literals`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `len`, perhaps you need to implement it:\n             candidate #1: `ExactSizeIterator`\nhelp: one of the expressions' fields has a method of the same name\n     |\n1580 |     assert_eq!(lits.lits.len(), 2);\n     |                     +++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1580:34\n     |\n1580 |     assert!(lits.add_char_class(&hir::ClassUnicode::new()));\n     |                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1580 |     assert!(lits.add_char_class(&hir::ClassUnicode::new(/* ranges */)));\n     |                                                        ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1580:34\n     |\n1580 |     assert!(lits.add_byte_class(&hir::ClassBytes::new()));\n     |                                  ^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:922:12\n     |\n922  |     pub fn new<I>(ranges: I) -> ClassBytes\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1580 |     assert!(lits.add_byte_class(&hir::ClassBytes::new(/* ranges */)));\n     |                                                      ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n    --> regex-syntax/src/hir/literal/mod.rs:1583:33\n     |\n1558 | {\n     | - closing delimiter possibly meant for this\n...\n1583 |     repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {\n     |                                 ^ unclosed delimiter\n...\n1587 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/literal/mod.rs:1587:3\n     |\n1553 | mod llmtests {\n     |              - unclosed delimiter\n...\n1587 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1569:15\n     |\n1569 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1569 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1579:28\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                            ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1579 |     let expr = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                            ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![1]),",
                "            Literal::new(vec![2]),",
                "            Literal::new(vec![3]),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 3,",
                "    };",
                "",
                "    let expr = Hir {",
                "        kind: HirKind::Literal,",
                "        info: HirInfo::new(),",
                "    };",
                "",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(2);",
                "        // Add multiple literals to ensure lits3 is not empty",
                "        lits3.add(Literal::new(vec![4]));",
                "        lits3.add(Literal::new(vec![5]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![1]),",
                  "    Literal::new(vec![2]),",
                  "    Literal::new(vec![3]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 3,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    lits3.set_limit_size(2);",
                  "    lits3.add(Literal::new(vec![4]));",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    assert!(!lits3.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![1]),",
                  "    Literal::new(vec![2]),",
                  "    Literal::new(vec![3]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 3,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    lits3.set_limit_size(2);",
                  "    lits3.add(Literal::new(vec![4]));",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    assert!(lits2.cross_product(&lits3));"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![1]),",
                  "    Literal::new(vec![2]),",
                  "    Literal::new(vec![3]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 3,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    lits3.set_limit_size(2);",
                  "    lits3.add(Literal::new(vec![4]));",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    assert!(!lits.union(lits2));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1]),",
                  "            Literal::new(vec![2]),",
                  "            Literal::new(vec![3]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 3,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(2);",
                  "        // Add multiple literals to ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4]));",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![1]),",
                  "    Literal::new(vec![2]),",
                  "    Literal::new(vec![3]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 3,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    lits3.set_limit_size(2);",
                  "    lits3.add(Literal::new(vec![4]));",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    assert!(!lits3.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1]),",
                  "            Literal::new(vec![2]),",
                  "            Literal::new(vec![3]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 3,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(2);",
                  "        // Add multiple literals to ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4]));",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![1]),",
                  "    Literal::new(vec![2]),",
                  "    Literal::new(vec![3]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 3,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    lits3.set_limit_size(2);",
                  "    lits3.add(Literal::new(vec![4]));",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    assert!(lits2.cross_product(&lits3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1]),",
                  "            Literal::new(vec![2]),",
                  "            Literal::new(vec![3]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 3,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(2);",
                  "        // Add multiple literals to ensure lits3 is not empty",
                  "        lits3.add(Literal::new(vec![4]));",
                  "        lits3.add(Literal::new(vec![5]));",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![1]),",
                  "    Literal::new(vec![2]),",
                  "    Literal::new(vec![3]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 3,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    lits3.set_limit_size(2);",
                  "    lits3.add(Literal::new(vec![4]));",
                  "    lits3.add(Literal::new(vec![5]));",
                  "    assert!(!lits.union(lits2));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:5\n     |\n1593 |     lits3.set_limit_size(2);\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1594:5\n     |\n1594 |     lits3.add(Literal::new(vec![4]));\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1595:5\n     |\n1595 |     lits3.add(Literal::new(vec![5]));\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1596:14\n     |\n1596 |     assert!(!lits3.is_empty());\n     |              ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1570 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1590:11\n     |\n1590 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1590 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:5\n     |\n1593 |     lits3.set_limit_size(2);\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1594:5\n     |\n1594 |     lits3.add(Literal::new(vec![4]));\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1595:5\n     |\n1595 |     lits3.add(Literal::new(vec![5]));\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1596:13\n     |\n1596 |     assert!(lits2.cross_product(&lits3));\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1596:34\n     |\n1596 |     assert!(lits2.cross_product(&lits3));\n     |                                  ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1570 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1590:11\n     |\n1590 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1590 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:5\n     |\n1593 |     lits3.set_limit_size(2);\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1594:5\n     |\n1594 |     lits3.add(Literal::new(vec![4]));\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1595:5\n     |\n1595 |     lits3.add(Literal::new(vec![5]));\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1596:25\n     |\n1596 |     assert!(!lits.union(lits2));\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1570:15\n     |\n1570 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1570 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1590:11\n     |\n1590 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1590 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![10]),",
                "            Literal::new(vec![20]),",
                "            Literal::new(vec![30]),",
                "            Literal::new(vec![40]),",
                "        ],",
                "        limit_size: 25,",
                "        limit_class: 4,",
                "    };",
                "",
                "    let expr = Hir {",
                "        kind: HirKind::Literal,",
                "        info: HirInfo::new(),",
                "    };",
                "",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(5);",
                "        // Ensure lits3 has at least one literal",
                "        lits3.add(Literal::new(vec![50]));",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.limit_size() == 25);"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert_eq!(lits.literals().len(), 4);"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.union(Literal::new(vec![50])));"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert_eq!(lits.literals().len(), 5);"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.limit_class == 4);"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.min_len().is_some());"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.any_complete());"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(!lits.all_complete());"
                ],
                [
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(!lits.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.limit_size() == 25);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert_eq!(lits.literals().len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.union(Literal::new(vec![50])));",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert_eq!(lits.literals().len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.limit_class == 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.min_len().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(!lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10]),",
                  "            Literal::new(vec![20]),",
                  "            Literal::new(vec![30]),",
                  "            Literal::new(vec![40]),",
                  "        ],",
                  "        limit_size: 25,",
                  "        limit_class: 4,",
                  "    };",
                  "",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(5);",
                  "        // Ensure lits3 has at least one literal",
                  "        lits3.add(Literal::new(vec![50]));",
                  "    });",
                  "    let lits = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![10]),",
                  "    Literal::new(vec![20]),",
                  "    Literal::new(vec![30]),",
                  "    Literal::new(vec![40]),",
                  "    ],",
                  "    limit_size: 25,",
                  "    limit_class: 4,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal,",
                  "    info: HirInfo::new(),",
                  "    };",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1594:24\n     |\n1594 |     assert!(lits.union(Literal::new(vec![50])));\n     |                  ----- ^^^^^^^^^^^^^^^^^^^^^^ expected `Literals`, found `Literal`\n     |                  |\n     |                  arguments to this method are incorrect\n     |\nnote: method defined here\n    --> regex-syntax/src/hir/literal/mod.rs:353:12\n     |\n353  |     pub fn union(&mut self, lits: Literals) -> bool {\n     |            ^^^^^            --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:15\n     |\n1572 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1592:11\n     |\n1592 |     info: HirInfo::new(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         kind: HirKind::Literal,\n     |               ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1571 |         kind: HirKind::Literal(/* hir::Literal */),\n     |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:11\n     |\n1591 |     kind: HirKind::Literal,\n     |           ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1591 |     kind: HirKind::Literal(/* hir::Literal */),\n     |                           ++++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: lits3.is_empty() is false\n",
        "// constraint: lits2.cross_product(&lits3) is false\n"
      ],
      "input_infer": "limit_size: 1 to 1, limit_class: 0 to 0, lits size: 0 to 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                "    ",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                "        // No operations performed, lits3 will remain empty",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.is_empty(), true);"
                ],
                [
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.limit_size(), 1);"
                ],
                [
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.limit_class(), 0);"
                ],
                [
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.literals().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // No operations performed, lits3 will remain empty",
                  "    });",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.is_empty(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // No operations performed, lits3 will remain empty",
                  "    });",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.limit_size(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // No operations performed, lits3 will remain empty",
                  "    });",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.limit_class(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    ",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, _| {",
                  "        // No operations performed, lits3 will remain empty",
                  "    });",
                  "    let mut lits = Literals::empty().set_limit_size(1).set_limit_class(0);",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    assert_eq!(lits.literals().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1560:50\n     |\n1560 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:50\n     |\n1566 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1560:50\n     |\n1560 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:50\n     |\n1566 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1560:50\n     |\n1560 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:50\n     |\n1566 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1560:50\n     |\n1560 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:50\n     |\n1566 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal::new(vec![1]);",
                "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                "",
                "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                "        // lits3 will receive elements but will fail the cross_product check",
                "        let lit3 = Literal::new(vec![2]);",
                "        lits3.add(lit3);",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(result, ());"
                ],
                [
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(lits.limit_size(), 1);"
                ],
                [
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(lits.limit_class(), 0);"
                ],
                [
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(lits.literals().len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        // lits3 will receive elements but will fail the cross_product check",
                  "        let lit3 = Literal::new(vec![2]);",
                  "        lits3.add(lit3);",
                  "    });",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(result, ());",
                  "}"
                ],
                [
                  "{",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        // lits3 will receive elements but will fail the cross_product check",
                  "        let lit3 = Literal::new(vec![2]);",
                  "        lits3.add(lit3);",
                  "    });",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        // lits3 will receive elements but will fail the cross_product check",
                  "        let lit3 = Literal::new(vec![2]);",
                  "        lits3.add(lit3);",
                  "    });",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(lits.limit_size(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        // lits3 will receive elements but will fail the cross_product check",
                  "        let lit3 = Literal::new(vec![2]);",
                  "        lits3.add(lit3);",
                  "    });",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(lits.limit_class(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "",
                  "    repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "        // lits3 will receive elements but will fail the cross_product check",
                  "        let lit3 = Literal::new(vec![2]);",
                  "        lits3.add(lit3);",
                  "    });",
                  "    let lit = Literal::new(vec![1]);",
                  "    let mut lits = Literals { lits: vec![lit.clone()], limit_size: 1, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let result = repeat_zero_or_more_literals(&expr, &mut lits, |_, lits3| {",
                  "    let lit3 = Literal::new(vec![2]);",
                  "    lits3.add(lit3);",
                  "    });",
                  "    assert_eq!(lits.literals().len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |     let expr = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}