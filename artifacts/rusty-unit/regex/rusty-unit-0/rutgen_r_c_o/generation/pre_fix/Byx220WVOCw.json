{
  "name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::add_capture_name",
  "name_with_impl": "regex_syntax::ast::parse::{impl#4}::add_capture_name",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:21:1:21:15"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/parse.rs:438:5:454:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: names.binary_search_by_key(\n            &cap.name.as_str(),\n            |c| c.name.as_str(),\n        ) matches Err(i) is true\n",
        "// constraint: names.binary_search_by_key(\n            &cap.name.as_str(),\n            |c| c.name.as_str(),\n        ) matches Err(i) is true\n",
        "// constraint: names.insert(i, cap.clone()) is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 < capture_name_count < 1000 (unique capture names allowed in the parser)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut parser = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    ",
                "    let capture_name = CaptureName {",
                "        span: Span { start: Position(0), end: Position(5) },",
                "        name: \"unique_name\".to_string(),",
                "        index: 0,",
                "    };",
                "    ",
                "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                "    parser_instance.add_capture_name(&capture_name);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow().len(), 1);"
                ],
                [
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow()[0].name, \"unique_name\");"
                ],
                [
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow()[0].span.start, Position(0));"
                ],
                [
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow()[0].span.end, Position(5));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"unique_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name);",
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"unique_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name);",
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"unique_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name);",
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow()[0].name, \"unique_name\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"unique_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name);",
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow()[0].span.start, Position(0));",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"unique_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name);",
                  "    let mut parser = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.add_capture_name(&capture_name);",
                  "    assert_eq!(parser.capture_names.borrow()[0].span.end, Position(5));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName {\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:24\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |   ...pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_white...\n     |                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:58\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:76\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName {\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:24\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |   ...pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_white...\n     |                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:58\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:76\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName {\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:24\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |   ...pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_white...\n     |                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:58\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:76\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName {\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:24\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |   ...pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_white...\n     |                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:58\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:76\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5399:61\n     |\n5399 |       assert_eq!(parser.capture_names.borrow()[0].span.start, Position(0));\n     |                                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName {\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:24\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:46\n     |\n5395 |   ...pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_white...\n     |                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:58\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:76\n     |\n5396 |       let capture_name = CaptureName { span: Span { start: Position(0), end: Position(5) }, name: \"unique_name\".to_string(), index: 0, };\n     |                                                                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5399:59\n     |\n5399 |       assert_eq!(parser.capture_names.borrow()[0].span.end, Position(5));\n     |                                                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut parser = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    ",
                "    let capture_name1 = CaptureName {",
                "        span: Span { start: Position(0), end: Position(5) },",
                "        name: \"duplicate_name\".to_string(),",
                "        index: 0,",
                "    };",
                "    ",
                "    let capture_name2 = CaptureName {",
                "        span: Span { start: Position(6), end: Position(11) },",
                "        name: \"duplicate_name\".to_string(),",
                "        index: 1,",
                "    };",
                "    ",
                "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                "    parser_instance.add_capture_name(&capture_name1);",
                "    parser_instance.add_capture_name(&capture_name2);",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let capture_name1 = CaptureName {",
                  "    span: Span { start: Position(0), end: Position(5) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 0,",
                  "    };",
                  "    let capture_name2 = CaptureName {",
                  "    span: Span { start: Position(6), end: Position(11) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 1,",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result1 = parser_instance.add_capture_name(&capture_name1);",
                  "    assert!(result1.is_ok());"
                ],
                [
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let capture_name1 = CaptureName {",
                  "    span: Span { start: Position(0), end: Position(5) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 0,",
                  "    };",
                  "    let capture_name2 = CaptureName {",
                  "    span: Span { start: Position(6), end: Position(11) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 1,",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result1 = parser_instance.add_capture_name(&capture_name1);",
                  "    let result2 = parser_instance.add_capture_name(&capture_name2);",
                  "    assert!(result2.is_err());"
                ],
                [
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let capture_name1 = CaptureName {",
                  "    span: Span { start: Position(0), end: Position(5) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 0,",
                  "    };",
                  "    let capture_name2 = CaptureName {",
                  "    span: Span { start: Position(6), end: Position(11) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 1,",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result1 = parser_instance.add_capture_name(&capture_name1);",
                  "    let result2 = parser_instance.add_capture_name(&capture_name2);",
                  "    assert_eq!(result2.unwrap_err().kind, ast::ErrorKind::GroupNameDuplicate { original: capture_name1.span });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name1 = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"duplicate_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let capture_name2 = CaptureName {",
                  "        span: Span { start: Position(6), end: Position(11) },",
                  "        name: \"duplicate_name\".to_string(),",
                  "        index: 1,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name1);",
                  "    parser_instance.add_capture_name(&capture_name2);",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let capture_name1 = CaptureName {",
                  "    span: Span { start: Position(0), end: Position(5) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 0,",
                  "    };",
                  "    let capture_name2 = CaptureName {",
                  "    span: Span { start: Position(6), end: Position(11) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 1,",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result1 = parser_instance.add_capture_name(&capture_name1);",
                  "    assert!(result1.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name1 = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"duplicate_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let capture_name2 = CaptureName {",
                  "        span: Span { start: Position(6), end: Position(11) },",
                  "        name: \"duplicate_name\".to_string(),",
                  "        index: 1,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name1);",
                  "    parser_instance.add_capture_name(&capture_name2);",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let capture_name1 = CaptureName {",
                  "    span: Span { start: Position(0), end: Position(5) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 0,",
                  "    };",
                  "    let capture_name2 = CaptureName {",
                  "    span: Span { start: Position(6), end: Position(11) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 1,",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result1 = parser_instance.add_capture_name(&capture_name1);",
                  "    let result2 = parser_instance.add_capture_name(&capture_name2);",
                  "    assert!(result2.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let capture_name1 = CaptureName {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        name: \"duplicate_name\".to_string(),",
                  "        index: 0,",
                  "    };",
                  "    ",
                  "    let capture_name2 = CaptureName {",
                  "        span: Span { start: Position(6), end: Position(11) },",
                  "        name: \"duplicate_name\".to_string(),",
                  "        index: 1,",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    parser_instance.add_capture_name(&capture_name1);",
                  "    parser_instance.add_capture_name(&capture_name2);",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let capture_name1 = CaptureName {",
                  "    span: Span { start: Position(0), end: Position(5) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 0,",
                  "    };",
                  "    let capture_name2 = CaptureName {",
                  "    span: Span { start: Position(6), end: Position(11) },",
                  "    name: \"duplicate_name\".to_string(),",
                  "    index: 1,",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result1 = parser_instance.add_capture_name(&capture_name1);",
                  "    let result2 = parser_instance.add_capture_name(&capture_name2);",
                  "    assert_eq!(result2.unwrap_err().kind, ast::ErrorKind::GroupNameDuplicate { original: capture_name1.span });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n5387 |     let capture_name1 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let capture_name2 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:25\n     |\n5415 |     let capture_name1 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5420:25\n     |\n5420 |     let capture_name2 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:29\n     |\n5394 |           span: Span { start: Position(6), end: Position(11) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:47\n     |\n5394 |           span: Span { start: Position(6), end: Position(11) },\n     |                                                 ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5403:20\n     |\n5403 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5416:25\n     |\n5416 |       span: Span { start: Position(0), end: Position(5) },\n     |                           ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5416:43\n     |\n5416 |       span: Span { start: Position(0), end: Position(5) },\n     |                                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5421:25\n     |\n5421 |       span: Span { start: Position(6), end: Position(11) },\n     |                           ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5421:43\n     |\n5421 |       span: Span { start: Position(6), end: Position(11) },\n     |                                             ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n5387 |     let capture_name1 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let capture_name2 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:25\n     |\n5415 |     let capture_name1 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5420:25\n     |\n5420 |     let capture_name2 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:29\n     |\n5394 |           span: Span { start: Position(6), end: Position(11) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:47\n     |\n5394 |           span: Span { start: Position(6), end: Position(11) },\n     |                                                 ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5403:20\n     |\n5403 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5416:25\n     |\n5416 |       span: Span { start: Position(0), end: Position(5) },\n     |                           ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5416:43\n     |\n5416 |       span: Span { start: Position(0), end: Position(5) },\n     |                                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5421:25\n     |\n5421 |       span: Span { start: Position(6), end: Position(11) },\n     |                           ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5421:43\n     |\n5421 |       span: Span { start: Position(6), end: Position(11) },\n     |                                             ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n5387 |     let capture_name1 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let capture_name2 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:25\n     |\n5415 |     let capture_name1 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5420:25\n     |\n5420 |     let capture_name2 = CaptureName {\n     |                         ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:47\n     |\n5388 |           span: Span { start: Position(0), end: Position(5) },\n     |                                                 ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:29\n     |\n5394 |           span: Span { start: Position(6), end: Position(11) },\n     |                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:47\n     |\n5394 |           span: Span { start: Position(6), end: Position(11) },\n     |                                                 ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5403:20\n     |\n5403 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5416:25\n     |\n5416 |       span: Span { start: Position(0), end: Position(5) },\n     |                           ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5416:43\n     |\n5416 |       span: Span { start: Position(0), end: Position(5) },\n     |                                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5421:25\n     |\n5421 |       span: Span { start: Position(6), end: Position(11) },\n     |                           ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5421:43\n     |\n5421 |       span: Span { start: Position(6), end: Position(11) },\n     |                                             ^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut parser = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let mut unique_capture_names = Vec::new();",
                "    for i in 0..999 {",
                "        unique_capture_names.push(CaptureName {",
                "            span: Span { start: Position(i), end: Position(i + 5) },",
                "            name: format!(\"name_{}\", i),",
                "            index: i as u32,",
                "        });",
                "    }",
                "    ",
                "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                "    ",
                "    for cap in unique_capture_names {",
                "        parser_instance.add_capture_name(&cap);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert_eq!(names.len(), 999);"
                ],
                [
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert!(names.iter().all(|c| c.name.starts_with(\"name_\")));"
                ],
                [
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert!(names.iter().enumerate().all(|(i, c)| c.index == i as u32));"
                ],
                [
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert!(names.iter().collect::<std::collections::HashSet<_>>().len() == names.len());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let mut unique_capture_names = Vec::new();",
                  "    for i in 0..999 {",
                  "        unique_capture_names.push(CaptureName {",
                  "            span: Span { start: Position(i), end: Position(i + 5) },",
                  "            name: format!(\"name_{}\", i),",
                  "            index: i as u32,",
                  "        });",
                  "    }",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    ",
                  "    for cap in unique_capture_names {",
                  "        parser_instance.add_capture_name(&cap);",
                  "    }",
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert_eq!(names.len(), 999);",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let mut unique_capture_names = Vec::new();",
                  "    for i in 0..999 {",
                  "        unique_capture_names.push(CaptureName {",
                  "            span: Span { start: Position(i), end: Position(i + 5) },",
                  "            name: format!(\"name_{}\", i),",
                  "            index: i as u32,",
                  "        });",
                  "    }",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    ",
                  "    for cap in unique_capture_names {",
                  "        parser_instance.add_capture_name(&cap);",
                  "    }",
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert!(names.iter().all(|c| c.name.starts_with(\"name_\")));",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let mut unique_capture_names = Vec::new();",
                  "    for i in 0..999 {",
                  "        unique_capture_names.push(CaptureName {",
                  "            span: Span { start: Position(i), end: Position(i + 5) },",
                  "            name: format!(\"name_{}\", i),",
                  "            index: i as u32,",
                  "        });",
                  "    }",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    ",
                  "    for cap in unique_capture_names {",
                  "        parser_instance.add_capture_name(&cap);",
                  "    }",
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert!(names.iter().enumerate().all(|(i, c)| c.index == i as u32));",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let mut unique_capture_names = Vec::new();",
                  "    for i in 0..999 {",
                  "        unique_capture_names.push(CaptureName {",
                  "            span: Span { start: Position(i), end: Position(i + 5) },",
                  "            name: format!(\"name_{}\", i),",
                  "            index: i as u32,",
                  "        });",
                  "    }",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    ",
                  "    for cap in unique_capture_names {",
                  "        parser_instance.add_capture_name(&cap);",
                  "    }",
                  "    let mut names = parser_instance.parser().capture_names.borrow_mut();",
                  "    assert!(names.iter().collect::<std::collections::HashSet<_>>().len() == names.len());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:35\n     |\n5389 |         unique_capture_names.push(CaptureName {\n     |                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:33\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:51\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                                     ^^^^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:35\n     |\n5389 |         unique_capture_names.push(CaptureName {\n     |                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:33\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:51\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                                     ^^^^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:35\n     |\n5389 |         unique_capture_names.push(CaptureName {\n     |                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:33\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:51\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                                     ^^^^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:35\n     |\n5389 |         unique_capture_names.push(CaptureName {\n     |                                   ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:33\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5390:51\n     |\n5390 |               span: Span { start: Position(i), end: Position(i + 5) },\n     |                                                     ^^^^^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0277]: the trait bound `ast::CaptureName: Hash` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5402:36\n     |\n5402 |     assert!(names.iter().collect::<std::collections::HashSet<_>>().len() == names.len());\n     |                          -------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Hash` is not implemented for `ast::CaptureName`, which is required by `HashSet<_>: FromIterator<&ast::CaptureName>`\n     |                          |\n     |                          required by a bound introduced by this call\n     |\n     = help: the trait `FromIterator<T>` is implemented for `HashSet<T, S>`\n     = note: required for `&ast::CaptureName` to implement `Hash`\n     = note: required for `HashSet<&ast::CaptureName>` to implement `FromIterator<&ast::CaptureName>`\nnote: required by a bound in `collect`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/iter/traits/iterator.rs:2001:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0423, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: names.binary_search_by_key(\n            &cap.name.as_str(),\n            |c| c.name.as_str(),\n        ) matches Ok(i) is true\n",
        "// constraint: names[i] is \n",
        "// expected return value/type: Err(self.error(cap.span, ast::ErrorKind::GroupNameDuplicate {\n                    original: names[i].span,\n                }))\n"
      ],
      "input_infer": "test input ranges: capture name length: 1 to 255 characters, capture index: 0 to 4294967295 (u32 max), span start: 0 to 255 (position), span end: 0 to 255 (position), total names: 1 to 100 (max duplicates), name duplication bounds: non-unique names for Ok(i) condition\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut parser = Parser {",
                "        pos: Cell::new(Position { /* initializer */ }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };",
                "",
                "    let parser_i = ParserI::new(&parser, \"pattern\");",
                "    let _ = parser_i.add_capture_name(&capture_name);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names.len(), 1);"
                ],
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names[0].name, \"duplicate\");"
                ],
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names[0].index, 0);"
                ],
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::GroupNameDuplicate { original: names[0].span });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names[0].name, \"duplicate\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names[0].index, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::GroupNameDuplicate { original: names[0].span });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:42\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                          ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:76\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:84\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:58\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:66\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:42\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                          ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:76\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:84\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:58\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:66\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:42\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                          ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:76\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:84\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:58\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:66\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:42\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                          ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:76\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:84\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:58\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:66\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:42\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                          ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5387:24\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:76\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5383:84\n     |\n5383 |         capture_names: RefCell::new(vec![CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 }]),\n     |                                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:58\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:66\n     |\n5387 |     let capture_name = CaptureName { span: Span { start: 2, end: 3 }, name: \"duplicate\".into(), index: 1 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut parser = Parser {",
                "        pos: Cell::new(Position { /* initializer */ }),",
                "        capture_index: Cell::new(1),",
                "        nest_limit: 20,",
                "        octal: true,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![",
                "            CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },",
                "            CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },",
                "        ]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };",
                "",
                "    let parser_i = ParserI::new(&parser, \"pattern\");",
                "    let _ = parser_i.add_capture_name(&capture_name);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut parser = Parser { pos: Cell::new(Position { /* initializer */ }), capture_index: Cell::new(1), nest_limit: 20, octal: true, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut parser = Parser { pos: Cell::new(Position { /* initializer */ }), capture_index: Cell::new(1), nest_limit: 20, octal: true, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ast::ErrorKind::GroupNameDuplicate { original: Span { start: 1, end: 2 } });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(1),",
                  "        nest_limit: 20,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: true,",
                  "        ignore_whitespace: Cell::new(true),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![",
                  "            CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },",
                  "            CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },",
                  "        ]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut parser = Parser { pos: Cell::new(Position { /* initializer */ }), capture_index: Cell::new(1), nest_limit: 20, octal: true, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(1),",
                  "        nest_limit: 20,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: true,",
                  "        ignore_whitespace: Cell::new(true),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![",
                  "            CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },",
                  "            CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },",
                  "        ]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut parser = Parser { pos: Cell::new(Position { /* initializer */ }), capture_index: Cell::new(1), nest_limit: 20, octal: true, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::new()), };",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ast::ErrorKind::GroupNameDuplicate { original: Span { start: 1, end: 2 } });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:13\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:13\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:24\n     |\n5390 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5394:342\n     |\n5394 | ...::new(vec![]), capture_names: RefCell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, Capt...\n     |                                                     ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5394:423\n     |\n5394 | ...: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ...\n     |                                                     ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:47\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:55\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:47\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:55\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:58\n     |\n5390 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:66\n     |\n5390 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:46\n     |\n5394 |     let mut parser = Parser { pos: Cell::new(Position { /* initializer */ }), capture_index: Cell::new(1), nest_limit: 20, octal: true, i...\n     |                                              ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:376\n     |\n5394 | ...ell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, e...\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:384\n     |\n5394 | ...(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 },...\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:457\n     |\n5394 | ...), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::...\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:465\n     |\n5394 | ...: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::new()), };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:58\n     |\n5395 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:66\n     |\n5395 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:13\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:13\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:24\n     |\n5390 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5394:342\n     |\n5394 | ...::new(vec![]), capture_names: RefCell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, Capt...\n     |                                                     ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5394:423\n     |\n5394 | ...: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ...\n     |                                                     ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:47\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:55\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:47\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:55\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:58\n     |\n5390 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:66\n     |\n5390 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:46\n     |\n5394 |     let mut parser = Parser { pos: Cell::new(Position { /* initializer */ }), capture_index: Cell::new(1), nest_limit: 20, octal: true, i...\n     |                                              ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:376\n     |\n5394 | ...ell::new(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, e...\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:384\n     |\n5394 | ...(vec![ CaptureName { span: Span { start: 0, end: 1 }, name: \"first\".into(), index: 0 }, CaptureName { span: Span { start: 1, end: 2 },...\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:457\n     |\n5394 | ...), index: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::...\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:465\n     |\n5394 | ...: 0 }, CaptureName { span: Span { start: 1, end: 2 }, name: \"duplicate\".into(), index: 1 }, ]), scratch: RefCell::new(String::new()), };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:58\n     |\n5395 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:66\n     |\n5395 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 2 };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:89\n     |\n5399 |     assert_eq!(error.kind, ast::ErrorKind::GroupNameDuplicate { original: Span { start: 1, end: 2 } });\n     |                                                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5399:97\n     |\n5399 |     assert_eq!(error.kind, ast::ErrorKind::GroupNameDuplicate { original: Span { start: 1, end: 2 } });\n     |                                                                                                 ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut parser = Parser {",
                "        pos: Cell::new(Position { /* initializer */ }),",
                "        capture_index: Cell::new(2),",
                "        nest_limit: 30,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![",
                "            CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },",
                "            CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },",
                "            CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },",
                "        ]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                "",
                "    let parser_i = ParserI::new(&parser, \"pattern\");",
                "    let _ = parser_i.add_capture_name(&capture_name);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names.len(), 3);"
                ],
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    if let Err(error) = result {",
                  "    assert_eq!(error.kind, ast::ErrorKind::GroupNameDuplicate { original: names[1].span });"
                ],
                [
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    if let Err(error) = result {",
                  "    }",
                  "    assert_eq!(names.len(), 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(2),",
                  "        nest_limit: 30,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![",
                  "            CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },",
                  "            CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },",
                  "            CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },",
                  "        ]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    assert_eq!(names.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(2),",
                  "        nest_limit: 30,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![",
                  "            CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },",
                  "            CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },",
                  "            CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },",
                  "        ]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(2),",
                  "        nest_limit: 30,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![",
                  "            CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },",
                  "            CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },",
                  "            CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },",
                  "        ]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    if let Err(error) = result {",
                  "    assert_eq!(error.kind, ast::ErrorKind::GroupNameDuplicate { original: names[1].span });",
                  "}"
                ],
                [
                  "{",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(Position { /* initializer */ }),",
                  "        capture_index: Cell::new(2),",
                  "        nest_limit: 30,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![",
                  "            CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },",
                  "            CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },",
                  "            CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },",
                  "        ]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "",
                  "    let parser_i = ParserI::new(&parser, \"pattern\");",
                  "    let _ = parser_i.add_capture_name(&capture_name);",
                  "    let mut names = parser.capture_names.borrow_mut();",
                  "    let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };",
                  "    let result = parser_i.add_capture_name(&capture_name);",
                  "    if let Err(error) = result {",
                  "    }",
                  "    assert_eq!(names.len(), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:13\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:13\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:13\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:24\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:47\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:55\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:47\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:55\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:47\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:55\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:58\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:66\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:13\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:13\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:13\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:24\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:24\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:47\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:55\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:47\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:55\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:47\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:55\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:58\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:66\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:58\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:66\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5401:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5401 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:13\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:13\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:13\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |             ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5391:24\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `CaptureName` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:24\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                        ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::CaptureName;\n     |\n5368 +    use ast::GroupKind::CaptureName;\n     |\n5368 +    use hir::GroupKind::CaptureName;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(Position { /* initializer */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:47\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5384:55\n     |\n5384 |             CaptureName { span: Span { start: 0, end: 1 }, name: \"duplicate\".into(), index: 0 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:47\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5385:55\n     |\n5385 |             CaptureName { span: Span { start: 1, end: 1 }, name: \"unique\".into(), index: 1 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:47\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5386:55\n     |\n5386 |             CaptureName { span: Span { start: 2, end: 2 }, name: \"duplicate\".into(), index: 2 },\n     |                                                       ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:58\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:66\n     |\n5391 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:58\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5396:66\n     |\n5396 |     let capture_name = CaptureName { span: Span { start: 3, end: 4 }, name: \"duplicate\".into(), index: 3 };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}