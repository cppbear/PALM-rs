{
  "name": "regex::re_bytes::re_bytes::Regex::is_match",
  "name_with_impl": "regex::re_bytes::{impl#5}::is_match",
  "mod_info": {
    "name": "re_bytes",
    "loc": "src/lib.rs:662:1:662:14"
  },
  "visible": true,
  "loc": "src/re_bytes.rs:141:5:143:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "text: [0], [1], [255], [b'a'; 13], [b'a'; 12], [b'a'; 14], [], [b'a'; 1000], [b'a'; 0], [0; 100], [b'a'; 5000]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex = Regex::new(r\"\\b\\w{1,}\\b\").unwrap();",
                "    regex.is_match(&[]);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex = Regex::new(r\"\\b\\w{1,}\\b\").unwrap();",
                  "    assert!(!regex.is_match(&[]));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex = Regex::new(r\"\\b\\w{1,}\\b\").unwrap();",
                  "    regex.is_match(&[]);",
                  "    let regex = Regex::new(r\"\\b\\w{1,}\\b\").unwrap();",
                  "    assert!(!regex.is_match(&[]));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                "    regex.is_match(&[1]);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                  "    assert!(regex.is_match(&[1]) == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                  "    regex.is_match(&[1]);",
                  "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                  "    assert!(regex.is_match(&[1]) == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                "    regex.is_match(&[255]);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                  "    assert!(!regex.is_match(&[255]));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                  "    regex.is_match(&[255]);",
                  "    let regex = Regex::new(r\"\\b\\w{1}\\b\").unwrap();",
                  "    assert!(!regex.is_match(&[255]));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                "    regex.is_match(b\"aaaaaaaaaaa\");",
                "}"
              ],
              "oracles": [
                [
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    assert!(!regex.is_match(b\"aaaaaaaaaaa\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    regex.is_match(b\"aaaaaaaaaaa\");",
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    assert!(!regex.is_match(b\"aaaaaaaaaaa\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                "    regex.is_match(b\"aaaaaaaaaaa\");",
                "}"
              ],
              "oracles": [
                [
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    assert!(!regex.is_match(b\"aaaaaaaaaaa\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    regex.is_match(b\"aaaaaaaaaaa\");",
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    assert!(!regex.is_match(b\"aaaaaaaaaaa\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                "    regex.is_match(b\"aaaaaaaaaaaaa\");",
                "}"
              ],
              "oracles": [
                [
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    assert!(!regex.is_match(b\"aaaaaaaaaaaaa\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    regex.is_match(b\"aaaaaaaaaaaaa\");",
                  "    let regex = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
                  "    assert!(!regex.is_match(b\"aaaaaaaaaaaaa\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text = vec![b'a'; 100];",
                "    let regex = Regex::new(r\"\\b\\w{100}\\b\").unwrap();",
                "    regex.is_match(&text);",
                "}"
              ],
              "oracles": [
                [
                  "    let text = vec![b'a'; 100];",
                  "    let regex = Regex::new(r\"\\b\\w{100}\\b\").unwrap();",
                  "    assert!(regex.is_match(&text) == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text = vec![b'a'; 100];",
                  "    let regex = Regex::new(r\"\\b\\w{100}\\b\").unwrap();",
                  "    regex.is_match(&text);",
                  "    let text = vec![b'a'; 100];",
                  "    let regex = Regex::new(r\"\\b\\w{100}\\b\").unwrap();",
                  "    assert!(regex.is_match(&text) == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex = Regex::new(r\"\\b\\w{0}\\b\").unwrap();",
                "    regex.is_match(b\"a\");",
                "}"
              ],
              "oracles": [
                [
                  "    let regex = Regex::new(r\"\\b\\w{0}\\b\").unwrap();",
                  "    assert!(regex.is_match(b\"a));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex = Regex::new(r\"\\b\\w{0}\\b\").unwrap();",
                  "    regex.is_match(b\"a\");",
                  "    let regex = Regex::new(r\"\\b\\w{0}\\b\").unwrap();",
                  "    assert!(regex.is_match(b\"a));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0766]: unterminated double quote byte string\n    --> src/re_bytes.rs:1085:29\n     |\n1085 |       assert!(regex.is_match(b\"a));\n     |  _____________________________^\n1086 | | }\n1087 | | }\n     | |__^\n\nFor more information about this error, try `rustc --explain E0766`.\nerror: could not compile `regex` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text = vec![b'a'; 5000];",
                "    let regex = Regex::new(r\"\\b\\w{5000}\\b\").unwrap();",
                "    regex.is_match(&text);",
                "}"
              ],
              "oracles": [
                [
                  "    let text = vec![b'a'; 5000];",
                  "    let regex = Regex::new(r\"\\b\\w{5000}\\b\").unwrap();",
                  "    assert!(!regex.is_match(&text));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text = vec![b'a'; 5000];",
                  "    let regex = Regex::new(r\"\\b\\w{5000}\\b\").unwrap();",
                  "    regex.is_match(&text);",
                  "    let text = vec![b'a'; 5000];",
                  "    let regex = Regex::new(r\"\\b\\w{5000}\\b\").unwrap();",
                  "    assert!(!regex.is_match(&text));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}